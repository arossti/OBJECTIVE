<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Tetrahedron Winding Test</title>
    <link rel="stylesheet" href="art.css" />
    <style>
      body {
        font-family: "Courier New", monospace;
        padding: 20px;
        background: #1a1a1a;
        color: #00ff00;
      }
      h1 {
        color: #00ff00;
      }
      h2 {
        color: #ffaa00;
      }
      .pass {
        color: #00ff00;
        font-weight: bold;
      }
      .fail {
        color: #ff0000;
        font-weight: bold;
      }
      .warning {
        color: #ffaa00;
      }
      .info {
        color: #00aaff;
      }
      pre {
        background: #000;
        padding: 10px;
        border: 1px solid #333;
        border-radius: 4px;
        overflow-x: auto;
      }
      .test-result {
        margin: 20px 0;
        padding: 15px;
        background: #222;
        border-left: 4px solid #00ff00;
        border-radius: 4px;
      }
      .test-result.fail {
        border-left-color: #ff0000;
      }
      .face-detail {
        margin-left: 20px;
        font-size: 0.9em;
      }
    </style>
  </head>
  <body>
    <!-- Password Protection Overlay -->
    <div id="password-overlay">
      <div id="password-modal">
        <h2>Tetrahedron Winding Test</h2>
        <p>This test is password protected.</p>
        <input
          type="password"
          id="password-input"
          placeholder="Enter password"
          autocomplete="off"
        />
        <button id="password-submit">Access</button>
        <div id="password-error">Incorrect password. Please try again.</div>
      </div>
    </div>

    <div id="test-content" style="display: none">
      <h1>ğŸ”¬ Tetrahedron Face Winding Order Test</h1>
      <p class="info">
        Testing base tetrahedron and geodesic subdivisions for correct face
        winding.
      </p>

      <div id="results"></div>
    </div>

    <script type="module">
      import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.167.0/build/three.module.js";
      import {
        Polyhedra,
        validateFaceWinding,
      } from "./modules/rt-polyhedra.js";

      // Make THREE global for modules
      window.THREE = THREE;

      // PASSWORD PROTECTION
      const PASSWORD = "enzyme2026!";
      const passwordOverlay = document.getElementById("password-overlay");
      const passwordInput = document.getElementById("password-input");
      const passwordSubmit = document.getElementById("password-submit");
      const passwordError = document.getElementById("password-error");
      const testContent = document.getElementById("test-content");

      function checkPassword() {
        if (passwordInput.value === PASSWORD) {
          sessionStorage.setItem("winding-test-auth", "true");
          passwordOverlay.style.display = "none";
          testContent.style.display = "block";
          runTests();
        } else {
          passwordError.style.display = "block";
          passwordInput.value = "";
          passwordInput.focus();
        }
      }

      // Check if already authenticated
      if (sessionStorage.getItem("winding-test-auth") === "true") {
        passwordOverlay.style.display = "none";
        testContent.style.display = "block";
        runTests();
      } else {
        passwordInput.focus();
        passwordSubmit.addEventListener("click", checkPassword);
        passwordInput.addEventListener("keypress", e => {
          if (e.key === "Enter") checkPassword();
        });
      }

      // TEST CODE
      function runTests() {
        const resultsDiv = document.getElementById("results");

        function logResult(html) {
          resultsDiv.innerHTML += html;
        }

        function testPolyhedron(name, polyData) {
          logResult(
            `<div class="test-result ${polyData.validation.isValid ? "pass" : "fail"}">`
          );
          logResult(`<h2>Testing: ${name}</h2>`);

          const v = polyData.validation;

          logResult(`<p><strong>Total Faces:</strong> ${v.totalFaces}</p>`);
          logResult(
            `<p class="pass">âœ… Correct: ${v.correctCount} (${((v.correctCount / v.totalFaces) * 100).toFixed(1)}%)</p>`
          );

          if (v.errorCount > 0) {
            logResult(`<p class="fail">âŒ Errors: ${v.errorCount}</p>`);
          }

          if (v.warningCount > 0) {
            logResult(`<p class="warning">âš ï¸ Warnings: ${v.warningCount}</p>`);
          }

          // Show face details
          if (polyData.poly.faces.length <= 20) {
            logResult(`<h3>Face Details:</h3>`);
            polyData.poly.faces.forEach((face, idx) => {
              const error = v.errors.find(e => e.faceIndex === idx);
              const warning = v.warnings.find(w => w.faceIndex === idx);

              let status = "âœ…";
              let className = "pass";
              let detail = "";

              if (error) {
                status = "âŒ";
                className = "fail";
                detail = ` - ${error.message}`;
              } else if (warning) {
                status = "âš ï¸";
                className = "warning";
                detail = ` - ${warning.warning}`;
              }

              logResult(
                `<div class="face-detail ${className}">${status} Face ${idx}: [${face.join(", ")}]${detail}</div>`
              );
            });
          }

          // Show errors in detail
          if (v.errors.length > 0) {
            logResult(`<h3 class="fail">Error Details:</h3>`);
            logResult("<pre>");
            v.errors.forEach(err => {
              logResult(
                `Face ${err.faceIndex}: vertices [${err.vertices.join(", ")}]\n`
              );
              logResult(`  ${err.message}\n`);
              if (err.dotProduct !== undefined) {
                logResult(`  Dot product: ${err.dotProduct.toFixed(6)}\n`);
                logResult(
                  `  Face normal:  (${err.faceNormal.x.toFixed(4)}, ${err.faceNormal.y.toFixed(4)}, ${err.faceNormal.z.toFixed(4)})\n`
                );
                logResult(
                  `  Outward dir:  (${err.outwardDir.x.toFixed(4)}, ${err.outwardDir.y.toFixed(4)}, ${err.outwardDir.z.toFixed(4)})\n`
                );
              }
              logResult("\n");
            });
            logResult("</pre>");
          }

          // Overall result
          if (v.isValid) {
            logResult(
              `<p class="pass"><strong>âœ… PASS:</strong> All faces correctly wound!</p>`
            );
          } else {
            logResult(
              `<p class="fail"><strong>âŒ FAIL:</strong> ${v.errorCount} face(s) need correction</p>`
            );
          }

          logResult("</div>");
        }

        // Test 1: Base Tetrahedron
        logResult(
          '<h2 class="info">â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•</h2>'
        );
        const tetra = Polyhedra.tetrahedron(1);
        const tetraValidation = validateFaceWinding(
          tetra.vertices,
          tetra.faces
        );
        testPolyhedron("Base Tetrahedron", {
          poly: tetra,
          validation: tetraValidation,
        });

        // Test 2: Dual Tetrahedron
        logResult(
          '<h2 class="info">â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•</h2>'
        );
        const dualTetra = Polyhedra.dualTetrahedron(1);
        const dualTetraValidation = validateFaceWinding(
          dualTetra.vertices,
          dualTetra.faces
        );
        testPolyhedron("Dual Tetrahedron", {
          poly: dualTetra,
          validation: dualTetraValidation,
        });

        // Test 3: Geodesic Tetrahedron (frequency = 1, should be same as base)
        logResult(
          '<h2 class="info">â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•</h2>'
        );
        const geoTetra1 = Polyhedra.geodesicTetrahedron(1, 1);
        const geoTetra1Validation = validateFaceWinding(
          geoTetra1.vertices,
          geoTetra1.faces
        );
        testPolyhedron("Geodesic Tetrahedron (freq=1)", {
          poly: geoTetra1,
          validation: geoTetra1Validation,
        });

        // Test 4: Geodesic Tetrahedron (frequency = 2)
        logResult(
          '<h2 class="info">â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•</h2>'
        );
        const geoTetra2 = Polyhedra.geodesicTetrahedron(1, 2);
        const geoTetra2Validation = validateFaceWinding(
          geoTetra2.vertices,
          geoTetra2.faces
        );
        testPolyhedron("Geodesic Tetrahedron (freq=2)", {
          poly: geoTetra2,
          validation: geoTetra2Validation,
        });

        // Test 5: Geodesic Tetrahedron (frequency = 3)
        logResult(
          '<h2 class="info">â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•</h2>'
        );
        const geoTetra3 = Polyhedra.geodesicTetrahedron(1, 3);
        const geoTetra3Validation = validateFaceWinding(
          geoTetra3.vertices,
          geoTetra3.faces
        );
        testPolyhedron("Geodesic Tetrahedron (freq=3)", {
          poly: geoTetra3,
          validation: geoTetra3Validation,
        });

        // Summary
        logResult(
          '<h2 class="info">â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•</h2>'
        );
        logResult("<h2>Test Summary</h2>");

        const allTests = [
          { name: "Base Tetrahedron", result: tetraValidation },
          { name: "Dual Tetrahedron", result: dualTetraValidation },
          {
            name: "Geodesic Tetrahedron (freq=1)",
            result: geoTetra1Validation,
          },
          {
            name: "Geodesic Tetrahedron (freq=2)",
            result: geoTetra2Validation,
          },
          {
            name: "Geodesic Tetrahedron (freq=3)",
            result: geoTetra3Validation,
          },
        ];

        let totalTests = allTests.length;
        let passedTests = allTests.filter(t => t.result.isValid).length;
        let failedTests = totalTests - passedTests;

        logResult("<pre>");
        allTests.forEach(test => {
          const status = test.result.isValid ? "âœ… PASS" : "âŒ FAIL";
          const className = test.result.isValid ? "pass" : "fail";
          logResult(
            `<span class="${className}">${status}</span>  ${test.name} (${test.result.correctCount}/${test.result.totalFaces} correct)\n`
          );
        });
        logResult("</pre>");

        if (failedTests === 0) {
          logResult(
            `<p class="pass"><strong>ğŸ‰ ALL TESTS PASSED!</strong> (${passedTests}/${totalTests})</p>`
          );
        } else {
          logResult(
            `<p class="fail"><strong>âš ï¸ TESTS FAILED:</strong> ${failedTests}/${totalTests} need correction</p>`
          );
        }
      } // End runTests()
    </script>
  </body>
</html>
