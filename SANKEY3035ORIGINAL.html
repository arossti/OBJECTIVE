<!DOCTYPE html>
<html lang="en">
<!-- v3032 Optimized calculations, revised Energy Balance, Matched PHPP nGainsFactor logic. Excel Mapping Complete. Add Cooling Sankey -->
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Energy Flow Sankey Diagram</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/d3-sankey@0.12.3/dist/d3-sankey.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
<style>
:root {
  --primary-blue: #4A96BA;
  --primary-red: #BE343D;
  --background-light: #f8f9fa;
  --border-color: #ddd;
  --text-dark: #333;
  --text-muted: #666;
  --box-shadow: 0 2px 4px rgba(0,0,0,0.05);
  --border-radius: 4px;
  --spacing-xs: 4px;
  --spacing-sm: 8px;
  --spacing-md: 12px;
  --spacing-lg: 15px;
  --spacing-xl: 20px;
  --font-size-sm: 12px;
  --font-size-md: 14px;
}

/* Base Layout */
body {
  font-family: Arial, sans-serif;
  margin: 0 auto;
  max-width: 1800px;
  padding: var(--spacing-xl);
  min-width: 400px;
}

/* Layout Components */
.container {
  display: flex;
  gap: var(--spacing-sm);
  margin-top: var(--spacing-sm);
  flex-direction: column;
  min-width: 0;
}

.button-row {
  display: flex;
  align-items: center;
  gap: var(--spacing-md);
  padding: var(--spacing-sm) 0;
  border-bottom: 1px solid var(--border-color);
  flex-wrap: wrap;
}

.status-row {
  min-height: 24px;
  padding: var(--spacing-xs) 0;
}

.file-input-group {
  display: flex;
  align-items: center;
  gap: var(--spacing-sm);
}

.diagram-container {
  flex: 0 0 auto;
  width: 100%;
  overflow-x: auto;
}

.controls-container {
  flex: 1 1 610px;
  min-width: 400px;
  background: white;
  padding: var(--spacing-lg);
  border-radius: var(--border-radius);
  border: 1px solid var(--border-color);
  box-shadow: var(--box-shadow);
  font-size: var(--font-size-sm);
}

.controls-container h3,
.controls-container h4 {
  font-size: var(--font-size-md);
  margin: 0;
  color: var(--text-dark);
}

/* Sankey Elements */
.node {
  stroke: #000;
  stroke-width: 1px;
  cursor: pointer;
}

.link {
  fill: none;
  stroke-opacity: 0.7;
  cursor: pointer;
}

.link:hover {
  stroke-opacity: 0.9;
}

.node-label {
  font-size: var(--font-size-sm);
  fill: black;
  pointer-events: none;
  font-weight: 500;
}

/* Tables Layout */
.tables-container {
  display: flex;
  gap: 20px;
  margin-top: 15px;
  flex-wrap: wrap;
  width: 100%;
  min-width: 0;
  overflow-x: auto;
}

@media (max-width: 1200px) {
  .table-section:first-child,
  .table-section:last-child {
    flex: 1 1 100%;
    min-width: 0;
  }
  
  .table-section:first-child {
    margin-bottom: var(--spacing-md);
  }
}

.table-section:first-child {
  flex: 0 0 35%;
  min-width: 400px;
  margin-right: 20px;
}

.table-section:last-child {
  flex: 1 0 60%;
  min-width: 700px;
}

.controls-table {
  width: 100%;
  border-collapse: collapse;
  font-size: var(--font-size-sm);
  table-layout: fixed;
}

.controls-table th,
.controls-table td {
  padding: 1px 4px;
  border: none;
  text-align: left;
  white-space: nowrap;
  overflow: hidden;
}

.controls-table {
  border-spacing: 0 2px;
  border-collapse: separate;
}

/* Table Column Widths */
.table-section:first-child .controls-table th:first-child,
.table-section:first-child .controls-table td:first-child {
  width: 300px;
  min-width: 300px;
}

.table-section:last-child .controls-table th:first-child,
.table-section:last-child .controls-table td:first-child {
  width: 280px;
  min-width: 280px;
}

.table-section:last-child .controls-table th:nth-child(2),
.table-section:last-child .controls-table td:nth-child(2) {
  width: 90px;
  min-width: 90px;
}

.table-section:last-child .controls-table th:nth-child(3),
.table-section:last-child .controls-table td:nth-child(3) {
  width: 430px;
  min-width: 430px;
  padding-right: var(--spacing-xl);
}

/* Control Headers */
.controls-table th:nth-child(3) .header-grid {
  display: grid;
  grid-template-columns: 100px 60px 60px;
  gap: var(--spacing-md);
  align-items: center;
  padding: 0 var(--spacing-sm);
}

.controls-table th:nth-child(3) .header-cell {
  text-align: left;
  white-space: nowrap;
  overflow: visible;
  padding-left: var(--spacing-xs);
}

/* Slider Layout */
.slider-cell {
  display: grid;
  grid-template-columns: 140px 60px;
  gap: var(--spacing-sm);
  align-items: center;
  padding: 0;
  min-width: 200px;
}

.slider-group {
  display: flex;
  align-items: center;
  gap: var(--spacing-xs);
  justify-content: flex-start;
}

/* Input Elements */
.slider-cell input[type="range"] {
  width: 80px;
  min-width: 80px;
  accent-color: var(--text-muted);
}

.slider-cell input[type="number"] {
  text-align: right;
  padding: 2px var(--spacing-xs) 2px 0;
  margin-left: var(--spacing-xs);
}

.slider-cell input[type="number"]:first-child {
  width: 80px;
  min-width: 80px;
}

.slider-cell input[type="number"]:not(:first-child) {
  width: 60px;
  min-width: 60px;
}

#widthMultiplier {
  height: 20px;
  margin: 0;
}

/* Value Display */
.value-display {
  min-width: 110px;
  text-align: right;
  font-size: var(--font-size-sm);
  font-weight: 500;
  color: var(--text-dark);
  padding-right: var(--spacing-xs);
}

/* Tooltip */
.tooltip {
  position: absolute;
  padding: var(--spacing-md);
  background: rgba(255, 255, 255, 0.98);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius);
  pointer-events: none;
  font-size: var(--font-size-sm);
  box-shadow: var(--box-shadow);
  max-width: 300px;
  line-height: 1.4;
  z-index: 1000;
}

.tooltip-title {
  font-weight: 600;
  margin-bottom: var(--spacing-sm);
  padding-bottom: var(--spacing-sm);
  border-bottom: 1px solid var(--border-color);
}

.tooltip-value {
  color: var(--text-muted);
}

.tooltip-flow {
  display: flex;
  justify-content: space-between;
  margin: var(--spacing-xs) 0;
}

/* Buttons */
button {
  padding: 6px var(--spacing-md);
  cursor: pointer;
  background-color: #f5f5f5;
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius);
  font-size: var(--font-size-sm);
  height: 30px;
  display: flex;
  align-items: center;
  justify-content: center;
  white-space: nowrap;
}

button:hover {
  background-color: #e5e5e5;
}

#importButton {
  background-color: #2196F3;
  color: white;
  border: none;
}

#importButton:hover {
  background-color: #1976D2;
}

#applyButton {
  background-color: #4CAF50;
  color: white;
  border: none;
}

#applyButton:hover {
  background-color: #45a049;
}

#applyButton:disabled {
  background-color: #cccccc;
  cursor: not-allowed;
}

/* Width Toggle */
.width-toggle {
  display: flex;
  align-items: center;
  gap: var(--spacing-sm);
  padding: 3px var(--spacing-md);
  background: #f5f5f5;
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius);
  height: 23px;
}

.width-toggle label {
  font-size: var(--font-size-sm);
  color: var(--text-dark);
}

/* Status Indicators */
#fileName {
  color: var(--text-muted);
  font-size: var(--font-size-sm);
  margin-left: var(--spacing-sm);
}

#statusMessage {
  font-size: var(--font-size-sm);
  padding: var(--spacing-xs) var(--spacing-sm);
  border-radius: var(--border-radius);
}

.status-success {
  color: #4CAF50;
  background-color: #E8F5E9;
}

.status-error {
  color: #f44336;
  background-color: #FFEBEE;
}

.status-pending {
  color: #2196F3;
  background-color: #E3F2FD;
}

/* Efficiency Controls */
.efficiency-controls {
  transition: max-height 0.3s ease-in-out;
  overflow: hidden;
}

.efficiency-controls.collapsed {
  max-height: 0;
}

.efficiency-controls.expanded {
  max-height: 500px;
}

.toggle-button {
  display: flex;
  align-items: center;
  gap: var(--spacing-sm);
  padding: var(--spacing-sm);
  background: var(--background-light);
  border: none;
  width: 100%;
  cursor: pointer;
  justify-content: flex-start;
}

.toggle-button i {
  transition: transform 0.3s ease;
}

.toggle-button.collapsed i {
  transform: rotate(-90deg);
}

/* Base print styles */
@media print {
  body {
    margin: 0.25in;
    padding: 0;
  }

  .button-row,
  .status-row {
    display: none;
  }

  .container {
    display: flex;
    flex-direction: column;
    gap: 0.5in;
  }

  .diagram-container {
    width: 100%;          /* Default for screen */
    max-width: 8in;       /* Maximum width for print */
    margin: 0 auto;       /* Center the container */
    padding: 0 20px;      /* Add padding on both sides */
    box-sizing: border-box;  /* Include padding in width calculation */
    overflow: visible;    /* Allow content to be fully visible */
  }
  
  /* Print-specific styles */
  @media print {
    .diagram-container {
      width: 8in;
      padding: 0;        /* Remove padding for print */
      overflow: visible;
    }
  }

  .controls-container {
    box-shadow: none;
    border: none;
    padding: 0;
  }

  .tables-container {
    break-before: page;
  }
}

.print-guide {
  position: relative;  /* Changed from fixed */
  width: 8.5in;
  margin: 10px auto;  /* Added margin */
  pointer-events: none;
  opacity: 0.4;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 4px;
}

.print-guide::before,
.print-guide::after {
  content: "+";
  color: #666;
  font-family: monospace;
}

.print-guide span {
  border-top: 1px solid #666;
  flex-grow: 1;
  text-align: center;
  font-size: 11px;
  font-family: monospace;
  color: #666;
  padding-top: 2px;
}

@media print {
  /* Base layout adjustments */
  body {
    margin: 0.5in;
    padding: 0;
    -webkit-print-color-adjust: exact;
    print-color-adjust: exact;
  }

  * {
    text-rendering: optimizeLegibility;
  }

  /* Container layouts */
  .container {
    gap: 0.25in;
  }

  .diagram-container {
    width: 8in;
    page-break-after: always;
  }

  .controls-container {
    page-break-before: always;
    border: none;
    box-shadow: none;
  }

  /* Table and control improvements */
  .controls-table td,
  .controls-table th {
    padding: 4px 8px;
    border-color: #aaa;
  }

  .slider-cell {
    gap: 8px;
  }

  .slider-cell input[type="number"] {
    text-align: right;
    padding: 2px 4px;
  }

  /* Input styling cleanup */
  select,
  input[type="number"] {
    -webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
    border: 1px solid #888;
    border-radius: 2px;
    box-shadow: none;
    background: white;
  }

  select {
    background-image: none;
    padding-right: 4px;
  }

  /* Efficiency section cleanup */
  .efficiency-controls {
    border: none;
    padding: 8px 0;
  }

  .toggle-button {
    background: none;
    padding: 4px 0;
  }

  .cost-calculator,
  .efficiency-section {
    background: none !important;
    border: none !important;
    padding: 0 !important;
  }

  /* Number display improvements */
  .value-display {
    font-feature-settings: "tnum";
    font-variant-numeric: tabular-nums;
  }

  /* Hide elements not needed in print */
  .button-row,
  .status-row,
  .print-guide,
  input[type="range"] {
    display: none;
  }
}
</style>
</head>
<body>
<div class="button-row">
  <div class="file-input-group">
	<input type="file" id="csvFile" accept=".xlsx,.csv" style="display: none">
    <button id="importButton">Import</button>
    <span id="fileName"></span>
    <button id="applyButton" style="display: none;">Apply</button>
  </div>
  <button id="toggleSpacingButton">Energy Balance</button>
  <div class="width-toggle">
    <label for="widthMultiplier">Node Width:</label>
    <input type="range" id="widthMultiplier" min="100" max="800" value="100" step="10">
    <span id="widthValue">100%</span>
  </div>
  <button id="resetButton">Reset Values</button>
  <button id="toggleEmissionsButton" style="background-color: #808080; color: white;">Show Emissions</button>
<!-- New cost summary section -->
<div style="display: flex; align-items: center; gap: 12px; margin-left: 12px; padding: 0 12px; background: #f8f9fa; border-radius: 4px; border: 1px solid #e9ecef; height: 30px;">
  <div style="font-size: 14px; display: flex; align-items: center; gap: 4px;">
    <span>Gas:</span>
    <span style="font-weight: bold;">$<span id="gasCostDisplay">0.00</span></span>
    <span style="margin: 0 4px"></span>
  </div>
  <div style="font-size: 14px; display: flex; align-items: center; gap: 4px;">
    <span>Electricity:</span>
    <span style="font-weight: bold;">$<span id="electricityCostDisplay">0.00</span></span>
    <span style="margin: 0 4px"></span>
  </div>
  <div style="font-size: 14px; display: flex; align-items: center; gap: 4px;">
    <span>Annual:</span>
    <span style="font-weight: bold;">$<span id="totalEnergyCost">0.00</span></span>
  </div>
</div>

  <div class="status-row">
    <span id="statusMessage"></span>
  </div>

  <div class="container">
    <div class="diagram-container">
      <svg id="sankey" height="600"></svg>
      <div id="tooltip" class="tooltip" style="display: none;"></div>
    </div>
	
<div class="print-guide">
  <span>to print - resize your browser to the width of the two plus signs - to print</span>
</div>

    <div class="controls-container">  
	  <div class="cost-calculator" style="margin-bottom: 15px; padding: 5px; background: #f8f9fa; border-radius: 4px; border: 1px solid #e9ecef;">
		  <style>
		  .efficiency-controls {
		    transition: max-height 0.3s ease-in-out;
		    overflow: hidden;
		  }

		  .efficiency-controls.collapsed {
		    max-height: 0;
		  }

		  .efficiency-controls.expanded {
		    max-height: 500px;
		  }

		  .toggle-button {
		    display: flex;
		    align-items: center;
		    gap: 8px;
		    padding: 8px;
		    background: #f8f9fa;
		    border: none;
		    width: 100%;
		    cursor: pointer;
			justify-content: flex-start;
		  }

		  .toggle-button i {
		    transition: transform 0.3s ease;
		  }

		  .toggle-button.collapsed i {
		    transform: rotate(-90deg);
		  }
		  </style>
		  <div class="efficiency-section">
		    <button class="toggle-button">
		      <i>▼</i>
		      <span>System Efficiencies & Parameters</span>
		    </button>
		    <div class="efficiency-controls expanded">
	    <div style="display: flex; flex-wrap: wrap; gap: 6px;">
	      <!-- Energy Cost Section -->
	      <div style="display: flex; align-items: center; gap: 8px;">
	        <label for="energyCost" style="font-size: 12px;">Electricity $/kWh:</label>
	        <input type="number" id="energyCost" min="0" step="0.001" value="0.13" 
	               style="width: 80px; padding: 4px 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px;">
	      </div>

	      <!-- Gas Cost Section -->
	      <div style="display: flex; align-items: center; gap: 8px;">
	        <label for="gasCost" style="font-size: 12px;">Gas $/m³:</label>
	        <input type="number" id="gasCost" min="0" step="0.001" value="0.507" 
	               style="width: 80px; padding: 4px 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px;">
	      </div>

		  <!-- Grid Intensity Section -->
          <div style="display: flex; align-items: center; gap: 8px;">
            <label for="gridIntensity" style="font-size: 12px;">Grid Intensity (g/kWh):</label>
            <input type="number" id="gridIntensity" min="0" step="0.01" value="67.00" 
                   style="width: 80px; padding: 4px 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px;">
            <span style="font-size: 12px;">
              <span style="font-weight: bold;">Total:</span> <span id="totalEmissions">0.00</span> MTCO2e/yr
            </span>
          </div>
		  <!-- Building Parameters Section -->
		  <div style="margin-left: 12px; display: flex; align-items: center; gap: 8px;">
		    <label for="conditionedArea" style="font-size: 12px;">B.3 Conditioned Area (m²):</label>
		    <input type="number" id="conditionedArea" min="0.1" step="0.01" value="528.0" 
		           style="width: 80px; padding: 4px 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px;">
		    <label for="heatingDegreeDays" style="font-size: 12px;">HDD:</label>
		    <input type="number" id="heatingDegreeDays" min="0" max="9999" step="1" value="3540" 
		           style="width: 80px; padding: 4px 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px;">
		    <label for="groundFacingHeatingDegreeDays" style="font-size: 12px;">GFHDD:</label>
		    <input type="number" id="groundFacingHeatingDegreeDays" min="0" max="9999" step="1" value="1960" 
		           style="width: 80px; padding: 4px 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px;">
			<span style="font-size: 12px;">
			  <span style="font-weight: bold;">TEUI (Ex.Cool)</span> 
			  <span id="teuiValue">0.0</span> kWh/m²·yr
			  <span style="margin-left: 12px; font-weight: bold;">TEDI:</span>
			  <span id="tediValue">0.0</span> kWh/m²·yr
			</span>
		  </div>
          <!-- Efficiency Settings -->
          <div style="display: flex; flex-wrap: wrap; gap: 8px;">
            <div style="display: flex; align-items: center; gap: 8px;">
				<div style="display: flex; align-items: center; gap: 8px;">
				  <label for="heatingSystem" style="font-size: 12px;">M.1 Primary Heating:</label>
				  <select id="heatingSystem" 
				          style="width: 100px; padding: 4px 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px;">
				    <option value="Heatpump" selected>Heatpump</option>
				    <option value="Electricity">Electricity</option>
				    <option value="Gas">Fossil Gas</option>
				  </select>
				</div>
              <label for="copHeating" style="font-size: 12px;">
                <span id="copHeatingLabel">COP Heating</span>:
              </label>
              <input type="number" id="copHeating" min="0.1" max="20" step="0.01" value="3.66" 
                     style="width: 80px; padding: 4px 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px;">
            </div>
            <div style="display: flex; align-items: center; gap: 8px;">
              <label for="copCooling" style="font-size: 12px;">COP Cooling:</label>
              <input type="number" id="copCooling" min="0.1" max="20" step="0.01" value="2.66" 
                     style="width: 80px; padding: 4px 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px;">
            </div>
            <div style="display: flex; align-items: center; gap: 8px;">
              <label for="mvhrEfficiency" style="font-size: 12px;">MVHR Efficiency:</label>
              <input type="number" id="mvhrEfficiency" min="0" max="1.00" step="0.01" value="0.80" 
                     style="width: 80px; padding: 4px 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px;">
            </div>
            <div style="display: flex; align-items: center; gap: 8px;">
              <label for="dwhrEfficiency" style="font-size: 12px;">DWHR Efficiency:</label>
              <input type="number" id="dwhrEfficiency" min="0" max="1.00" step="0.01" value="0.00" 
                     style="width: 80px; padding: 4px 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px;">
            </div>
			<!-- Add after DWHR Efficiency control -->
			<div style="display: flex; align-items: center; gap: 8px;">
			  <label for="gainsFactorMethod" style="font-size: 12px;">G.3 Usable Gains:</label>
			  <select id="gainsFactorMethod" 
			          style="width: 80px; padding: 4px 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px;">
			    <option value="0.00001">0%</option>
			    <option value="0.4">40%</option>
			    <option value="0.5">50%</option>
			    <option value="0.6" selected>60%</option>
			    <option value="phpp">PHPP</option>
			  </select>
			  <span id="calculatedGainsFactor" style="font-size: 12px; color: #666; min-width: 60px;">(60%)</span>
			</div>
          </div>
        </div>
      </div>
	</div>

<div class="tables-container">
  <div class="table-section">
    <table class="controls-table">
      <thead>
        <tr>
          <th>Energy Supplied</th>
          <th style="width: 70px;">kWh/yr</th>
          <th>
            <div class="header-grid">
              <span class="header-cell">Use Sliders to Adjust</span>
              <span class="header-cell"></span>
              <span class="header-cell"></span>
            </div>
          </th>
        </tr>
      </thead>
      <tbody id="gainsControlsBody"></tbody>
    </table>
  </div>
  <div class="table-section">
    <table class="controls-table">
      <thead>
        <tr>
          <th>Energy Lost</th>
          <th style="width: 70px;">kWh/yr</th>
          <th>
            <div class="header-grid">
              <span class="header-cell">Area</span>
              <span class="header-cell">m²</span>
              <span class="header-cell">RSI & U-Value</span>
            </div>
          </th>
        </tr>
      </thead>
      <tbody id="lossesControlsBody"></tbody>
    </table>
  </div>
</div>
    </div>
  </div>
<script defer>
	// Script Block 1: Core Configuration and Initial Data Structure
	const CONFIG = {
	  // System Value Limits and Defaults
	  VALUE_LIMITS: {
	    COP_HEATING: { min: 0.001, max: 20, step: 0.01, default: 3.66 },
	    COP_COOLING: { min: 0.001, max: 20, step: 0.01, default: 2.66 },
	    MVHR: { min: 0, max: 1.0, step: 0.01, default: 0.8 },
	    DWHR: { min: 0, max: 1.0, step: 0.01, default: 0.0 },
	    GAS_EFFICIENCY: { min: 0.5, max: 0.98, step: 0.01, default: 0.9 },
	    GAINS_FACTOR: { min: 0, max: 1.0, step: 0.01, default: 0.6 },
	  },

	  // Emissions and Cost Factors
	  EMISSIONS: {
	    GAS_INTENSITY: 1921, // gCO2e/m3
	    GAS_ENERGY_DENSITY: 10.36, // ekWh/m3
	    DEFAULT_GAS_COST: 0.507, // $/m3
	    DEFAULT_ELECTRICITY_COST: 0.13, // $/kWh
	  },

	  // Building Elements Configuration
	  BUILDING_ELEMENTS: {
	    // Degree Days configurations
	    HDD: {
	      default: 3540,
	      min: 0,
	      max: 9999,
	      step: 1,
	    },
	    GFHDD: {
	      default: 1960, // Tset-10ºC*Days in Htg Season
	      min: 0,
	      max: 9999,
	      step: 1,
	    },

	// Component types mapped to their calculation method
	    COMPONENT_TYPES: {
	      ABOVE_GRADE: [
        "B.4 Roof",
        "B.5 Walls Above Grade",
        "B.6 Floor Exposed",
        "B.7.0 Doors",
	        "B.8.1 Windows N",
        "B.8.2 Windows E",
        "B.8.3 Windows S",
        "B.8.4 Windows W",
        "B.8.5 Skylights",
      ],
	      GROUND_FACING: ["B.9 Walls Below Grade", "B.10 Floor Slab"],
	    },

	    // Component configurations
	    COMPONENTS: {
	      ROOF: {
	        name: "B.4 Roof",
	        elementArea: { default: 528.0, min: 0, max: 9999, step: 0.01 },
	        uValue: { default: 0.137, min: 0.001, max: 3.0, step: 0.001 },
	        rsi: { default: 7.29, min: 0.1, max: 100.0, step: 0.01 },
	        type: "ABOVE_GRADE",
	      },
	      WALLS_ABOVE_GRADE: {
	        name: "B.5 Walls Above Grade",
	        elementArea: { default: 0.0, min: 0, max: 9999, step: 0.01 },
	        uValue: { default: 0.176, min: 0.001, max: 3.0, step: 0.001 },
	        rsi: { default: 5.67, min: 0.1, max: 100.0, step: 0.01 },
	        type: "ABOVE_GRADE",
	      },
	      FLOOR_EXPOSED: {
	        name: "B.6 Floor Exposed",
	        elementArea: { default: 0.0, min: 0, max: 9999, step: 0.01 },
	        uValue: { default: 0.105, min: 0.001, max: 3.0, step: 0.001 },
	        rsi: { default: 9.52, min: 0.1, max: 100.0, step: 0.01 },
	        type: "ABOVE_GRADE",
	      },
	      DOORS: {
	        name: "B.7.0 Doors",
	        elementArea: { default: 2.0, min: 0, max: 100, step: 0.01 },
	        uValue: { default: 1.2, min: 0.001, max: 3.0, step: 0.001 },
	        rsi: { default: 0.833, min: 0.1, max: 5.0, step: 0.01 },
	        type: "ABOVE_GRADE",
	      },
	      WINDOWS_N: {
	        name: "B.8.1 Windows N",
	        elementArea: { default: 105.0, min: 0, max: 1000, step: 0.01 },
	        uValue: { default: 1.2, min: 0.001, max: 3.0, step: 0.001 },
	        rsi: { default: 0.833, min: 0.1, max: 5.0, step: 0.01 },
	        type: "ABOVE_GRADE",
	      },
	      WINDOWS_E: {
	        name: "B.8.2 Windows E",
	        elementArea: { default: 61.6, min: 0, max: 1000, step: 0.01 },
	        uValue: { default: 1.2, min: 0.001, max: 3.0, step: 0.001 },
	        rsi: { default: 0.833, min: 0.1, max: 5.0, step: 0.01 },
	        type: "ABOVE_GRADE",
	      },
	      WINDOWS_S: {
	        name: "B.8.3 Windows S",
	        elementArea: { default: 105.0, min: 0, max: 1000, step: 0.01 },
	        uValue: { default: 1.2, min: 0.001, max: 3.0, step: 0.001 },
	        rsi: { default: 0.833, min: 0.1, max: 5.0, step: 0.01 },
	        type: "ABOVE_GRADE",
	      },
	      WINDOWS_W: {
	        name: "B.8.4 Windows W",
	        elementArea: { default: 61.6, min: 0, max: 1000, step: 0.01 },
	        uValue: { default: 1.2, min: 0.001, max: 3.0, step: 0.001 },
	        rsi: { default: 0.833, min: 0.1, max: 5.0, step: 0.01 },
	        type: "ABOVE_GRADE",
	      },
	      SKYLIGHTS: {
	        name: "B.8.5 Skylights",
	        elementArea: { default: 1, min: 0, max: 9999, step: 0.01 },
	        uValue: { default: 0.9, min: 0.001, max: 3.0, step: 0.001 },
	        rsi: { default: 1.1111, min: 0.1, max: 5.0, step: 0.01 },
	        type: "ABOVE_GRADE",
	      },
	      WALLS_BELOW_GRADE: {
	        name: "B.9 Walls Below Grade",
	        elementArea: { default: 0.0, min: 0, max: 9999, step: 0.01 },
	        uValue: { default: 0.22, min: 0.001, max: 3.0, step: 0.001 },
	        rsi: { default: 4.55, min: 0.1, max: 100.0, step: 0.01 },
	        type: "GROUND_FACING",
	      },
	      FLOOR_SLAB: {
	        name: "B.10 Floor Slab",
	        elementArea: { default: 528.0, min: 0, max: 9999, step: 0.01 },
	        uValue: { default: 0.203, min: 0.001, max: 3.0, step: 0.001 },
	        rsi: { default: 4.93, min: 0.1, max: 100.0, step: 0.01 },
	        type: "GROUND_FACING",
	      },
	    },
	  },

	  // Excel/CSV Mapping Configuration updated for OBJECTIVE 3034
	  EXCEL_MAPPING: {
	    SHEETS: {
	      ENERGY_BALANCE: "ENERGY BALANCE",
	      REPORT: "REPORT",
	    },
	    NODE_VALUES: {
	      // Sources to Building
	      "G.1.2 Occupant Gains": "REPORT!I64",
	      "G.2 Plug Light Equipment": "REPORT!I70",
	      "W.5.2 SHW Net Demand": "REPORT!J52",
	      "G.7.0 Doors": "REPORT!I73",
	      "G.8.1 Windows N": "REPORT!I74",
	      "G.8.2 Windows E": "REPORT!I75",
	      "G.8.3 Windows S": "REPORT!I76",
	      "G.8.4 Windows W": "REPORT!I77",
	      "G.8.5 Skylights": "REPORT!I78",
	      "M.2.1.S Sink (Air/Ground)": "REPORT!L113", //Now M.1.4
	      "M.2.1.D Energy Input": "REPORT!D114",
	      "Thermal Energy Demand": "REPORT!D127",
	      // TEL (Total Envelope Losses in kWh)
	      "B.4 Roof": "REPORT!I85",
	      "B.5 Walls Above Grade": "REPORT!I86",
	      "B.6 Floor Exposed": "REPORT!I87",
	      "B.7.0 Doors": "REPORT!I88",
	      "B.8.1 Windows N": "REPORT!I89",
	      "B.8.2 Windows E": "REPORT!I90",
	      "B.8.3 Windows S": "REPORT!I91",
	      "B.8.4 Windows W": "REPORT!I92",
	      "B.8.5 Skylights": "REPORT!I93",
	      "B.9 Walls Below Grade": "REPORT!I94",
	      "B.10 Floor Slab": "REPORT!I95",
	      "B.12 TB Penalty": "REPORT!I97", // This is getting total losses - check I93 mapping error
	      "B.18.3 Air Leakage": "REPORT!I103",
	      // TEL (Total Envelope Losses by Area and U-value)
	      "Total Envelope Losses": "REPORT!D131", //Now T.5.1
      "B.4 Roof_area": "REPORT!D85",
	      "B.5 Walls Above Grade_area": "REPORT!D86",
      "B.6 Floor Exposed_area": "REPORT!D87",
      "B.7.0 Doors_area": "REPORT!D73",
      "B.8.1 Windows N_area": "REPORT!D74",
      "B.8.2 Windows E_area": "REPORT!D75",
      "B.8.3 Windows S_area": "REPORT!D76",
      "B.8.4 Windows W_area": "REPORT!D77",
      "B.8.5 Skylights_area": "REPORT!D78",
      "B.9 Walls Below Grade_area": "REPORT!D94",
      "B.10 Floor Slab_area": "REPORT!D95",
	      // U-Values + RSI Values
      "B.4 Roof_rsi": "REPORT!F85",
	      "B.5 Walls Above Grade_rsi": "REPORT!F86",
      "B.6 Floor Exposed_rsi": "REPORT!F87",
      "B.7.0 Doors_uvalue": "REPORT!G88",
      "B.8.1 Windows N_uvalue": "REPORT!G89",
      "B.8.2 Windows E_uvalue": "REPORT!G90",
      "B.8.3 Windows S_uvalue": "REPORT!G91",
      "B.8.4 Windows W_uvalue": "REPORT!G92",
	      "B.8.5 Skylights_uvalue": "REPORT!G93",
      "B.7.0 Doors_rsi": "REPORT!F88",
      "B.8.1 Windows N_rsi": "REPORT!F89",
      "B.8.2 Windows E_rsi": "REPORT!F90",
      "B.8.3 Windows S_rsi": "REPORT!F91",
      "B.8.4 Windows W_rsi": "REPORT!F92",
      "B.8.5 Skylights_rsi": "REPORT!F93",
      "B.9 Walls Below Grade_rsi": "REPORT!F94",
      "B.10 Floor Slab_rsi": "REPORT!F95",
	      "V.2.3 Unrecovered Ventilation": "REPORT!M121",
	      "W.2.W SHW Wasted": "REPORT!J53",
	      "G.5 Unusable Gains": "REPORT!I82",
	    },
	    GLOBAL_VALUES: {
	      COPh: "REPORT!H113", // M.1.2
	      COPc: "REPORT!J113", // M.1.3 Cell value is determined by system selections - may cause a null value if no A/C
	      MVHR: "REPORT!D118", // V.1.1
	      DWHR: "REPORT!D53", // W.5.1 DWHR Efficiency
	      ProjectName: "REPORT!H14",
	      ElectricityCost: "REPORT!L12", // $/kWh
	      GasCost: "REPORT!L13", // $/m³
	      GridIntensity: "REPORT!L27", // gCO2e/kWh - Electricity Only
	      "B.3 Conditioned Area": "REPORT!H15", // Conditioned Area Field for TEUI Calc
	      HDD: "REPORT!D20", // L.2.1 HDD
	      GFHDD: "REPORT!D22", // L.2.2 GFHDD
	      nGainsFactor: "REPORT!G80", // G.2 Net Usable Gains Factor as % value
	      "M.1 Primary Heating System": "REPORT!D113", // M.1.0 Imports Heating System by Type - check that it works!
	    },
	  },
	};
	
	const NodeReferenceHandler = {
	  convertToIndices(links, nodes) {
	    return links.map((link) => ({
	      source:
        typeof link.source === "object"
          ? nodes.indexOf(link.source)
          : link.source,
	      target:
        typeof link.target === "object"
          ? nodes.indexOf(link.target)
          : link.target,
	      value: link.value,
	      isEmissions: link.isEmissions, // Preserve emissions flag if present
	    }));
	  },

	  convertToObjects(links, nodes) {
	    return links.map((link) => ({
	      source:
        typeof link.source === "number" ? nodes[link.source] : link.source,
	      target:
        typeof link.target === "number" ? nodes[link.target] : link.target,
	      value: link.value,
	      isEmissions: link.isEmissions, // Preserve emissions flag if present
	    }));
	  },

	  validateNodeReferences(links, nodes) {
	    return links.every((link) => {
	      const sourceValid =
        typeof link.source === "number"
	          ? link.source >= 0 && link.source < nodes.length
	          : nodes.includes(link.source);

	      const targetValid =
        typeof link.target === "number"
          ? link.target >= 0 && link.target < nodes.length
	          : nodes.includes(link.target);

	      return sourceValid && targetValid;
	    });
	  },
	};

	// Initial Data Structure
	const INITIAL_DATA = {
	  nodes: [
	    { name: "Building", color: "#4A96BA" }, // [0] Central node - all flows connect here
	    { name: "G.1.2 Occupant Gains", color: "#FF8C00" }, // [1] Source: Internal gains from occupants
	    { name: "G.2 Plug Light Equipment", color: "#A5D3ED" }, // [2] Source: Equipment & lighting gains
	    { name: "W.5.2 SHW Net Demand", color: "#BE343D" }, // [3] Source: Hot water demand (affected by DWHR)
	    { name: "G.8.1 Windows N", color: "#F9DF4B" }, // [4] Source: North solar gains
	    { name: "G.8.2 Windows E", color: "#F9DF4B" }, // [5] Source: East solar gains
	    { name: "G.8.3 Windows S", color: "#F9DF4B" }, // [6] Source: South solar gains
	    { name: "G.8.4 Windows W", color: "#F9DF4B" }, // [7] Source: West solar gains
	    { name: "G.7.0 Doors", color: "#F9DF4B" }, // [8] Target: Door gains
	    { name: "M.2.1.S Sink (Air/Ground)", color: "#D4B26F" }, // [9] Source: Heat pump source side (air/ground)
	    { name: "M.2.1.D Energy Input", color: "#A9D7F2" }, // [10] Source: Heat pump electrical input or Gas input in Gas mode
	    { name: "Thermal Energy Demand", color: "#BFA586" }, // [11] Node: TED combines source + electric - or Gas
	    { name: "B.4 Roof", color: "#8FAFA6" }, // [12] Target: Roof heat loss
	    { name: "B.5 Walls Above Grade", color: "#8FAFA6" }, // [13] Target: Wall heat loss
	    { name: "B.6 Floor Exposed", color: "#8FAFA6" }, // [14] Target: Exposed floor heat loss
	    { name: "B.7.0 Doors", color: "#8FAFA6" }, // [15] Target: Door heat loss
	    { name: "B.8.1 Windows N", color: "#F9DF4B" }, // [16] Target: North window heat loss
	    { name: "B.8.2 Windows E", color: "#F9DF4B" }, // [17] Target: East window heat loss
	    { name: "B.8.3 Windows S", color: "#F9DF4B" }, // [18] Target: South window heat loss
	    { name: "B.8.4 Windows W", color: "#F9DF4B" }, // [19] Target: West window heat loss
	    { name: "B.9 Walls Below Grade", color: "#8FAFA6" }, // [20] Target: Below grade wall loss
	    { name: "B.10 Floor Slab", color: "#8FAFA6" }, // [21] Target: Slab heat loss
	    { name: "B.12 TB Penalty", color: "#8FAFA6" }, // [22] Target: Thermal bridge heat loss
	    { name: "B.18.3 Air Leakage", color: "#A4D3ED" }, // [23] Target: Air infiltration heat loss
	    { name: "V.2.3 Unrecovered Ventilation", color: "#A5D3ED" }, // [24] Target: Ventilation loss (affected by MVHR)
	    { name: "W.2.W SHW Wasted", color: "#BE343D" }, // [25] Target: Hot water waste (affected by DWHR)
	    { name: "G.5 Unusable Gains", color: "#FFA500" }, // [26] Target: Excess heat gains unused
	    { name: "GasExhaust", color: "#BE343D", hidden: true }, // [27] Target: Gas system exhaust heat
	    { name: "Total Envelope Losses", color: "#8FAFA6" }, // [28] Target: Total envelope heat loss
	    { name: "E1 Scope 1 Emissions", color: "#808080" }, // [29] Target: Direct emissions from gas
	    { name: "E2 Scope 2 Emissions", color: "#808080" }, // [30] Target: Indirect emissions from electricity
	    { name: "B.8.5 Skylights", color: "#F9DF4B" }, // [31] Target: Skylight heat loss
	    { name: "G.8.5 Skylights", color: "#F9DF4B" }, // [32] Target: Skylight heat gain
	  ],
	  links: [
	    // Sources flowing into Building node
	    { source: 1, target: 0, value: 12924.43 }, // 1 Occupant gains -> Building
	    { source: 2, target: 0, value: 13970.88 }, // 2 Equipment gains -> Building
	    { source: 3, target: 0, value: 4000.0 }, // 3 Hot water demand -> Building (reduced by DWHR)
	    { source: 4, target: 0, value: 137.55 }, // 4 North solar -> Building
	    { source: 5, target: 0, value: 4739.5 }, // 5 East solar -> Building
	    { source: 6, target: 0, value: 7427.7 }, // 6 South solar -> Building
	    { source: 7, target: 0, value: 1592.98 }, // 7 West solar -> Building
	    { source: 8, target: 0, value: 2.62 }, // 8 Door Gains -> Building
	    { source: 32, target: 0, value: 52.5 }, // 31 Skylight Gains -> Building

	    // Thermal Energy Demand system flows
	    { source: 9, target: 11, value: 27089.29 }, // Source -> Thermal Energy Demand (M21S)
	    { source: 10, target: 11, value: 10170.41 }, // Electric -> Thermal Energy Demand (M21D)
	    { source: 11, target: 0, value: 37259.69 }, // Heat pump -> Building (TED)

	    // TEL flows to envelope components
	    { source: 28, target: 12, value: 6152.64 }, // TEL -> Roof loss
	    { source: 28, target: 13, value: 0.001 }, // TEL -> Wall Ae loss
	    { source: 28, target: 14, value: 0.001 }, // TEL -> Floor Exposed loss
	    { source: 28, target: 15, value: 203.9 }, // TEL -> Door loss
	    { source: 28, target: 16, value: 10704.96 }, // TEL -> North window loss
	    { source: 28, target: 17, value: 6280.24 }, // TEL -> East window loss
	    { source: 28, target: 18, value: 10704.96 }, // TEL -> South window loss
	    { source: 28, target: 19, value: 6280.24 }, // TEL -> West window loss
	    { source: 28, target: 31, value: 76.46 }, // TEL -> West window loss
	    { source: 28, target: 20, value: 0.001 }, // TEL -> Wall Ag loss
    { source: 28, target: 21, value: 5037.96 }, // TEL -> Slab loss
	    { source: 28, target: 22, value: 9072.98 }, // TEL -> Thermal bridge heat loss
	    { source: 28, target: 23, value: 4729.17 }, // TEL -> Air leakage loss

	    // Direct losses from Building node
	    { source: 0, target: 24, value: 2570.04 }, // Building -> Net Ventilation loss (reduced by MVHR efficiency)
	    { source: 0, target: 25, value: 4000.0 }, // Building -> Net Hot water waste (reduced by DWHR)
	    { source: 0, target: 26, value: 16318.27 }, // Building -> G.5 Net Unusable gains
	    { source: 0, target: 27, value: 0.0001 }, // Where Building is index 0 and GasExhaust is index 27 - check where we fixed this in 6.7
	    { source: 0, target: 28, value: 59167.05 }, // Building -> TEL (total envelope loss)

	    // Gas mode flows
	    { source: 11, target: 27, value: 0.0001 }, // Thermal Energy Demand -> GasExhaust
	    { source: 3, target: 27, value: 0.0001 }, // SHW -> GasExhaust
	  ],
	};

	// System State Variables
	let data = JSON.parse(JSON.stringify(INITIAL_DATA));
	let originalData = JSON.parse(JSON.stringify(INITIAL_DATA));
	let pendingImportData = null;

	// System Parameters
	let COPh = CONFIG.VALUE_LIMITS.COP_HEATING.default;
	let previousCOPh = CONFIG.VALUE_LIMITS.COP_HEATING.default;
	let COPc = CONFIG.VALUE_LIMITS.COP_COOLING.default;
	let MVHR = CONFIG.VALUE_LIMITS.MVHR.default;
	let DWHR = CONFIG.VALUE_LIMITS.DWHR.default;
	let isGasHeating = false;

	// Heat Pump State Variables
	let TED = 0; // Total heat pump output
	let M21D = 0; // Heat pump energy input
	let M21S = 0; // Heat pump source input

	// Visualization State
	let spacingCollapsed = false;
	let widthMultiplier = 1;
	let showEmissions = false;
</script>
<!-- Script Block 2: Value State Management System -->
<script defer>
	class ValueState {
	  constructor(config) {
	    this._config = config;
	    this._default = config.default;
	    this._imported = null;
	    this._userEdited = null;
	    this._originalValue = null;

	    // Allow zero values in validation
	    this._validators = new Map([
	      ["percentage", (v) => v >= 0 && v <= 1],
	      ["positive", (v) => v >= 0], // Changed from v > 0 to allow zero
	      ["range", (v) => v >= this._config.min && v <= this._config.max],
	    ]);
	  }

	  reset() {
	    console.log(
      `Resetting value - imported: ${this._imported}, default: ${this._default}`,
    );
	    this._userEdited = null;
	    // If we have an imported value, restore to that, otherwise use default
	    if (this._imported !== null) {
	      console.log(`Reset to imported value: ${this._imported}`);
	      return this._imported;
	    }
	    console.log(`No imported value, reset to default: ${this._default}`);
	    return this._default;
	  }

	  get value() {
	    return this._userEdited ?? this._imported ?? this._default;
	  }

	  get isImported() {
	    return this._imported !== null;
	  }

	  get isUserEdited() {
	    return this._userEdited !== null;
	  }

	  get originalValue() {
	    return this._originalValue ?? this._default;
	  }

	  setImported(value) {
	    const normalized = this._normalize(value);
	    if (this._validate(normalized)) {
	      this._imported = normalized;
	      this._originalValue = normalized;
	      this._userEdited = null;
	      return true;
	    }
	    return false;
	  }

	  setUserEdited(value) {
	    const normalized = this._normalize(value);
	    if (this._validate(normalized)) {
	      this._userEdited = normalized;
	      return true;
	    }
	    return false;
	  }

	  _normalize(value) {
	    if (typeof value === "string") {
	      if (value.endsWith("%")) {
	        value = parseFloat(value) / 100;
	      } else {
	        value = parseFloat(value);
	      }
	    }
	    if (this._config.isPercentage && value > 1 && value <= 100) {
	      value = value / 100;
	    }
	    if (this._config.precision !== undefined) {
	      value = Number(value.toFixed(this._config.precision));
	    }
	    return value;
	  }

	  _validate(value) {
	    if (isNaN(value)) return false;
	    return Array.from(this._validators.entries())
	      .filter(([key]) => this._config[key])
	      .every(([_, validator]) => validator(value));
	  }
	}

const StateManager = {
  _states: new Map(),
  _listeners: new Map(),
  _dataState: {
    type: "default",
    data: null,
    userModifications: new Map(),
  },

  // NEW CODE
  _importedBaseline: null,

  setImportedBaseline(data) {
    this._importedBaseline = {
      nodes: data.nodes.map((node) => ({ ...node })),
      links: data.links.map((link) => ({ ...link })),
      componentUpdates: new Map(data.componentUpdates),
      globalUpdates: { ...data.globalUpdates },
    };
    console.log("New baseline set from import:", this._importedBaseline);
  },

  getBaselineData() {
    return this._importedBaseline || INITIAL_DATA;
  },
  // END NEW CODE

  initialize() {
    // System states
    const systemStates = {
      copHeating: {
        default: CONFIG.VALUE_LIMITS.COP_HEATING.default,
        min: CONFIG.VALUE_LIMITS.COP_HEATING.min,
        max: CONFIG.VALUE_LIMITS.COP_HEATING.max,
        precision: 1,
        positive: true,
        range: true,
      },
	      isGasHeating: {
	        default: false,
	        precision: 0,
	        range: false,
	        positive: false,
	      },
      copCooling: {
        default: CONFIG.VALUE_LIMITS.COP_COOLING.default,
        min: CONFIG.VALUE_LIMITS.COP_COOLING.min,
        max: CONFIG.VALUE_LIMITS.COP_COOLING.max,
        precision: 1,
        positive: true,
        range: true,
      },
      mvhrEfficiency: {
        default: CONFIG.VALUE_LIMITS.MVHR.default,
        min: CONFIG.VALUE_LIMITS.MVHR.min,
        max: CONFIG.VALUE_LIMITS.MVHR.max,
        precision: 2,
        isPercentage: true,
        range: true,
      },
      dwhrEfficiency: {
        default: CONFIG.VALUE_LIMITS.DWHR.default,
        min: CONFIG.VALUE_LIMITS.DWHR.min,
        max: CONFIG.VALUE_LIMITS.DWHR.max,
        precision: 2,
        isPercentage: true,
        range: true,
      },
      conditionedArea: {
        default: 528.0,
        min: 0.001,
        max: 100000,
        precision: 0.01,
        positive: true,
        range: true,
      },
      heatingDegreeDays: {
        default: CONFIG.BUILDING_ELEMENTS.HDD.default,
        min: CONFIG.BUILDING_ELEMENTS.HDD.min,
        max: CONFIG.BUILDING_ELEMENTS.HDD.max,
        step: CONFIG.BUILDING_ELEMENTS.HDD.step,
        precision: 0,
        positive: true,
        range: true,
      },
      groundFacingHeatingDegreeDays: {
        default: CONFIG.BUILDING_ELEMENTS.GFHDD.default,
        min: CONFIG.BUILDING_ELEMENTS.GFHDD.min,
        max: CONFIG.BUILDING_ELEMENTS.GFHDD.max,
        step: CONFIG.BUILDING_ELEMENTS.GFHDD.step,
        precision: 0,
        positive: true,
        range: true,
      },
	      nGainsFactor: {
	        default: CONFIG.VALUE_LIMITS.GAINS_FACTOR.default,
	        min: CONFIG.VALUE_LIMITS.GAINS_FACTOR.min,
	        max: CONFIG.VALUE_LIMITS.GAINS_FACTOR.max,
	        precision: 2,
	        isPercentage: true,
	        range: true,
	      },
    };

    // Initialize system states
    Object.entries(systemStates).forEach(([key, config]) => {
      this._states.set(key, new ValueState(config));
    });

    // Initialize component states
    Object.entries(CONFIG.BUILDING_ELEMENTS.COMPONENTS).forEach(
      ([key, component]) => {
        this._states.set(
          `${key.toLowerCase()}Area`,
          new ValueState({
            default: component.elementArea.default,
            min: component.elementArea.min,
            max: component.elementArea.max,
            precision: 2, // Changed from component.elementArea.step
	            step: 0.01, // Added explicit step
            positive: true,
            range: true,
          }),
        );
	
        // In StateManager.initialize()
	        Object.entries(CONFIG.BUILDING_ELEMENTS.COMPONENTS).forEach(
          ([key, component]) => {
	            this._states.set(
              `${key.toLowerCase()}Rsi`,
              new ValueState({
	                default: component.rsi.default,
	                min: component.rsi.min,
	                max: component.rsi.max,
	                precision: 2,
	                positive: true,
	                range: true,
	              }),
            );
	          },
        );

        this._states.set(
          `${key.toLowerCase()}UValue`,
          new ValueState({
            default: component.uValue.default,
            min: component.uValue.min,
            max: component.uValue.max,
            precision: 3, // Changed from component.uValue.step
	            step: 0.001, // Added explicit step
            positive: true,
            range: true,
          }),
        );
      },
    );

    console.log("=== StateManager Init ===");
    this.debugStates();
  },

  debugStates() {
    console.log("Current states:");
    this._states.forEach((state, key) => {
      console.log(`${key}:`, {
        value: state.value,
        imported: state.isImported,
        edited: state.isUserEdited,
      });
    });
  },

  getCurrentData() {
    const baseData = this._dataState.data;
    if (this._dataState.userModifications.size > 0) {
      const modifiedData = JSON.parse(JSON.stringify(baseData));
      this._dataState.userModifications.forEach((value, key) => {
        this._applyModification(modifiedData, key, value);
      });
      return modifiedData;
    }
    return baseData;
  },

  getValue(key) {
    return this._states.get(key)?.value ?? null;
  },

  // 2. In StateManager, ensure we're storing RSI as primary value:
  setValue(key, value, type = "user") {
    const state = this._states.get(key);
    if (!state) return false;

    // If this is a U-value being set, convert it to RSI first
    if (key.toLowerCase().includes("uvalue")) {
      console.warn(
        "Attempting to set U-value directly - this should not happen",
      );
      // Convert to RSI if a U-value is mistakenly provided
      const rsiKey = key.replace("UValue", "Rsi");
      const rsiState = this._states.get(rsiKey);
      if (rsiState) {
        const rsiValue = 1 / value;
        const success =
          type === "import"
            ? rsiState.setImported(rsiValue)
            : rsiState.setUserEdited(rsiValue);
        if (success) {
          this._notifyListeners(rsiKey, rsiState.value);
          return true;
        }
      }
      return false;
    }

    const success =
      type === "import" ? state.setImported(value) : state.setUserEdited(value);

    if (success) {
      this._notifyListeners(key, state.value);
      return true;
    }
    return false;
  },

  // In StateManager, update reset method
  reset() {
    console.log("=== StateManager Reset ===");
    console.log("Reset - Imported baseline:", this._importedBaseline);
    console.log(
      "Reset - Component updates:",
      this._importedBaseline?.componentUpdates,
    );

    const baselineData = this._importedBaseline || INITIAL_DATA;

    // Clear user modifications but keep imported data
    this._dataState.userModifications.clear();

    // Reset component states but preserve imported values
    this._states.forEach((state, key) => {
      if (this._importedBaseline?.componentUpdates?.has(key)) {
        // Use imported value
        const importedValue = this._importedBaseline.componentUpdates.get(key);
        state.setImported(importedValue);
      } else {
        // Reset to default
        state.reset();
      }
    });

    // Trigger recalculation
    EnergyCalculator.updateTEL(false);
    EnergyCalculator.updateBuildingBalance();

    return baselineData;
  },

  addListener(key, callback) {
    if (!this._listeners.has(key)) {
      this._listeners.set(key, new Set());
    }
    this._listeners.get(key).add(callback);
  },

  removeListener(key, callback) {
    this._listeners.get(key)?.delete(callback);
  },

  _validateStateData(data) {
    if (!data || typeof data !== "object") {
      console.log("State data validation failed: not an object", data);
      return false;
    }

    if (!data.globalUpdates || typeof data.globalUpdates !== "object") {
      console.log("Data validation failed: missing globalUpdates");
      return false;
    }

    if (!data.componentUpdates || !(data.componentUpdates instanceof Map)) {
      console.log("Data validation failed: missing componentUpdates");
      return false;
    }

    if (data.componentUpdates.size === 0) {
      console.log("Data validation failed: no component data");
      return false;
    }

    console.log("Data validation passed", data);
    return true;
  },

  _applyModification(data, key, value) {
    const [type, id] = key.split(":");
    if (type === "node") {
      const node = data.nodes.find((n) => n.name === id);
      if (node) Object.assign(node, value);
    } else if (type === "link") {
      const [source, target] = id.split("->");
      const link = data.links.find(
        (l) => l.source.name === source && l.target.name === target,
      );
      if (link) Object.assign(link, value);
    }
  },

  _notifyListeners(key, value) {
    this._listeners.get(key)?.forEach((callback) => callback(value));
  },
};

StateManager.initialize();
</script>
	<!-- Script Block 3: Data Management System -->
	<script defer>
	// Script Block 3: Node Utilities and Data Management
	const NodeUtils = {
	  findNodeIndex(name) {
	    return data.nodes.findIndex((node) => node.name === name);
	  },

	  getNodeByName(name) {
	    return data.nodes.find((node) => node.name === name);
	  },

	  getNodeIndex(node) {
	    if (!node) return null;
	    return typeof node === "number"
      ? node
	      : typeof node === "object"
        ? (node.index ?? data.nodes.indexOf(node))
        : null;
	  },

	  getSourceNodeIndex(link) {
	    if (!link?.source) return null;
	    return typeof link.source === "number"
      ? link.source
	      : typeof link.source === "object"
        ? (link.source.index ?? data.nodes.indexOf(link.source))
        : null;
	  },

	  getTargetNodeIndex(link) {
	    if (!link?.target) return null;
	    const index =
      typeof link.target === "number"
        ? link.target
	        : typeof link.target === "object"
          ? (link.target.index ?? data.nodes.indexOf(link.target))
          : null;

	    // Add verification
	    if (index === null || !data.nodes[index]) {
	      console.error("Invalid target node index:", index, link);
	      return null;
	    }
	    return index;
	  },

	  ensureNodeReferences() {
	    data.links.forEach((link) => {
	      if (typeof link.source === "number")
        link.source = data.nodes[link.source];
	      if (typeof link.target === "number")
        link.target = data.nodes[link.target];
	    });
	  },

	  validateLinkStructure(link) {
	    // Ensure link has proper object references
	    if (typeof link.source === "number") {
	      link.source = data.nodes[link.source];
	    }
	    if (typeof link.target === "number") {
	      link.target = data.nodes[link.target];
	    }

	    // Ensure value is numeric and valid
	    if (typeof link.value !== "number" || isNaN(link.value)) {
	      console.warn(
        `Invalid link value for ${link.source.name} -> ${link.target.name}`,
      );
	      link.value = 0.001; // Minimum valid value
	    }

	    return link;
	  },
	};

	const LinkUtils = {
	  findLink(sourceIndex, targetIndex) {
	    return data.links.find((link) => {
	      const linkSourceIndex =
        typeof link.source === "number"
          ? link.source
	          : data.nodes.indexOf(link.source);
	      const linkTargetIndex =
        typeof link.target === "number"
          ? link.target
	          : data.nodes.indexOf(link.target);
	      return linkSourceIndex === sourceIndex && linkTargetIndex === targetIndex;
	    });
	  },

	  findLinkIndex(sourceIndex, targetIndex) {
	    return data.links.findIndex(
      (link) =>
	        NodeUtils.getSourceNodeIndex(link) === sourceIndex &&
	        NodeUtils.getTargetNodeIndex(link) === targetIndex,
	    );
	  },

	  getLinkValue(sourceName, targetName) {
	    const sourceIndex = NodeUtils.findNodeIndex(sourceName);
	    const targetIndex = NodeUtils.findNodeIndex(targetName);
	    const link = this.findLink(sourceIndex, targetIndex);
	    return link ? link.value : 0;
	  },

	  updateLink(sourceIndex, targetIndex, newValue, silent = false) {
	    console.log(`=== Link Update ===`);
	    console.log(`Updating link: ${sourceIndex} → ${targetIndex} = ${newValue}`);

	    const linkIndex = this.findLinkIndex(sourceIndex, targetIndex);
	    if (linkIndex === -1) {
	      console.error("Link not found for update");
	      return false;
	    }

	    // Get node objects
	    const sourceNode = data.nodes[sourceIndex];
	    const targetNode = data.nodes[targetIndex];

    console.log(`Source node: ${sourceNode.name}`);
	    console.log(`Target node: ${targetNode.name}`);

	    // Enforce minimum value and update while maintaining object references
	    newValue = Math.max(0.1, newValue);
	    data.links[linkIndex] = {
	      ...data.links[linkIndex],
	      source: sourceNode, // Use node object, not index
	      target: targetNode, // Use node object, not index
	      value: newValue,
	    };

	    if (!silent) {
	      // Update UI display
	      const valueDisplay = document.querySelector(
	        `.value-display[data-source="${sourceNode.name}"][data-target="${targetNode.name}"]`,
	      );
	      if (valueDisplay) {
	        valueDisplay.textContent = newValue.toFixed(2);
	      }
	    }

	    console.log(`Link updated successfully`);
	    return true;
	  },

	  verifyNodeReferences() {
	    console.log(`=== Verifying Node References ===`);
	    let needsUpdate = false;

	    data.links.forEach((link, index) => {
	      if (typeof link.source === "number" || typeof link.target === "number") {
	        console.log(`Link ${index} needs object references updated`);
	        needsUpdate = true;
	      }
	    });

	    if (needsUpdate) {
	      NodeUtils.ensureNodeReferences();
	      console.log("Node references updated");
	    } else {
	      console.log("All node references are valid");
	    }
	  },
	
	  ensureValidLinkStructure(links = data.links) {
	    return links.map((link) => NodeUtils.validateLinkStructure({ ...link }));
	  },

	  updateLinkByNames(sourceName, targetName, newValue, silent = false) {
	    const sourceIndex = NodeUtils.findNodeIndex(sourceName);
	    const targetIndex = NodeUtils.findNodeIndex(targetName);
	    return this.updateLink(sourceIndex, targetIndex, newValue, silent);
	  },
	};

	const DataManager = {
	  isCalculatedFlow(sourceName, targetName) {
	    const calculatedFlows = [
	      { source: "M.2.1.S Sink (Air/Ground)", target: "Thermal Energy Demand" },
	      { source: "M.2.1.D Energy Input", target: "Thermal Energy Demand" },
	      { source: "Thermal Energy Demand", target: "Building" },
	      { source: "Thermal Energy Demand", target: "GasExhaust" },
	      { source: "Building", target: "G.5 Unusable Gains" },
	      { source: "Building", target: "Total Envelope Losses" },
	    ];

	    return calculatedFlows.some(
      (flow) => flow.source === sourceName && flow.target === targetName,
	    );
	  },

	  validateData(data) {
	    if (!data?.nodes || !data?.links) return false;

	    // Validate nodes
	    const requiredNodes = [
      "Building",
      "Thermal Energy Demand",
      "Total Envelope Losses",
    ];
	    const hasRequiredNodes = requiredNodes.every((nodeName) =>
	      data.nodes.some((node) => node.name === nodeName),
	    );
	    if (!hasRequiredNodes) return false;

	    // Validate critical links
	    const buildingIndex = NodeUtils.findNodeIndex("Building");
	    const telIndex = NodeUtils.findNodeIndex("Total Envelope Losses");

	    // Check building and TEL connections
	    const hasCriticalLinks = data.links.some(
      (link) =>
        NodeUtils.getSourceNodeIndex(link) === buildingIndex &&
        NodeUtils.getTargetNodeIndex(link) === telIndex,
	    );

	    return hasCriticalLinks;
	  },

	  backup() {
	    // Create a decycled version of the data structure
	    const decycledData = {
	      nodes: data.nodes.map((node) => ({
	        name: node.name,
	        color: node.color,
	        hidden: node.hidden,
	      })),
	      links: data.links.map((link) => ({
	        source:
          typeof link.source === "object" ? link.source.index : link.source,
	        target:
          typeof link.target === "object" ? link.target.index : link.target,
	        value: link.value,
	        isEmissions: link.isEmissions,
	      })),
	    };

	    const decycledOriginal = {
	      nodes: originalData.nodes.map((node) => ({
	        name: node.name,
	        color: node.color,
	        hidden: node.hidden,
	      })),
	      links: originalData.links.map((link) => ({
	        source:
          typeof link.source === "object" ? link.source.index : link.source,
	        target:
          typeof link.target === "object" ? link.target.index : link.target,
	        value: link.value,
	        isEmissions: link.isEmissions,
	      })),
	    };

	    return {
	      data: decycledData,
	      originalData: decycledOriginal,
	    };
	  },

	  restore(backup) {
	    if (
      !this.validateData(backup.data) ||
      !this.validateData(backup.originalData)
    ) {
	      return false;
	    }

	    // Restore data with proper node references
	    data = {
	      nodes: backup.data.nodes,
	      links: backup.data.links.map((link) => ({
	        source:
          backup.data.nodes[
            typeof link.source === "number" ? link.source : link.source.index
          ],
	        target:
          backup.data.nodes[
            typeof link.target === "number" ? link.target : link.target.index
          ],
	        value: link.value,
	        isEmissions: link.isEmissions,
	      })),
	    };

	    originalData = {
	      nodes: backup.originalData.nodes,
	      links: backup.originalData.links.map((link) => ({
	        source:
          backup.originalData.nodes[
            typeof link.source === "number" ? link.source : link.source.index
          ],
	        target:
          backup.originalData.nodes[
            typeof link.target === "number" ? link.target : link.target.index
          ],
	        value: link.value,
	        isEmissions: link.isEmissions,
	      })),
	    };

	    NodeUtils.ensureNodeReferences();
	    return true;
	  },

	  validateData(data) {
	    if (!data?.nodes || !data?.links) return false;

	    // Validate nodes
	    const requiredNodes = [
      "Building",
      "Thermal Energy Demand",
      "Total Envelope Losses",
    ];
	    const hasRequiredNodes = requiredNodes.every((nodeName) =>
	      data.nodes.some(
        (node) => node?.name === nodeName && typeof node.color === "string",
      ),
	    );
	    if (!hasRequiredNodes) return false;

	    // Validate critical links
	    const buildingNode = data.nodes.findIndex((n) => n.name === "Building");
	    const telNode = data.nodes.findIndex(
      (n) => n.name === "Total Envelope Losses",
    );

	    // Check building and TEL connections exist
	    const hasCriticalLinks = data.links.some((link) => {
	      const sourceIndex =
        typeof link.source === "number" ? link.source : link.source.index;
	      const targetIndex =
        typeof link.target === "number" ? link.target : link.target.index;
	      return sourceIndex === buildingNode && targetIndex === telNode;
	    });

	    return hasCriticalLinks;
	  },
	};
</script>
	<!-- Script Block 4: Energy Calculation Engine -->
	<script defer>
	// Script Block 4: Energy Calculation Engine
	const EnergyCalculator = {
	  PRECISION: {
	    AREA: 2,
	    U_VALUE: 3,
	    ENERGY: 2,
	  },

	  InitialBalance: {
	    targetValues: {
	      TED: 37259.69,
	      M21D: 10170.41,
	      M21S: 27089.29,
	      G5: 16318.27,
	      COPh: 3.66,
	    },

	    validateBalance() {
	      const tedSum = Math.abs(
        this.targetValues.M21D + this.targetValues.M21S - this.targetValues.TED,
      );
	      const copRatio = Math.abs(
        this.targetValues.TED / this.targetValues.M21D - this.targetValues.COPh,
      );

	      return {
	        isBalanced: tedSum < 0.1 && copRatio < 0.01,
	        tedDeviation: tedSum,
	        copDeviation: copRatio,
	      };
	    },

	    applyInitialValues() {
	      console.log("Applying initial balanced values");

	      TED = this.targetValues.TED;
	      M21D = this.targetValues.M21D;
	      M21S = this.targetValues.M21S;
	      COPh = this.targetValues.COPh;

	      LinkUtils.updateLinkByNames(
	        "M.2.1.S Sink (Air/Ground)",
	        "Thermal Energy Demand",
	        this.targetValues.M21S,
	        true,
	      );

	      LinkUtils.updateLinkByNames(
	        "M.2.1.D Energy Input",
	        "Thermal Energy Demand",
	        this.targetValues.M21D,
	        true,
	      );

	      LinkUtils.updateLinkByNames(
	        "Thermal Energy Demand",
	        "Building",
	        this.targetValues.TED,
	        true,
	      );

	      LinkUtils.updateLinkByNames(
	        "Building",
	        "G.5 Unusable Gains",
	        this.targetValues.G5,
	        true,
	      );

	      const balance = this.validateBalance();
	      console.log("Initial balance check:", balance);

	      return balance.isBalanced;
	    },
	  },

	  updateHeatPumpValues(requiredOutput) {
	    console.log("=== Start updateHeatPumpValues ===");
	    console.log("isGasHeating:", isGasHeating);
	    console.log("Current mode:", isGasHeating ? "GAS MODE" : "HEAT PUMP MODE");
	    if (!this.InitialBalance.isInitialized) {
	      if (this.InitialBalance.applyInitialValues()) {
	        console.log("Using initial balanced values");
	        this.InitialBalance.isInitialized = true;
	        return;
	      }
	    }

	    const minValue = 0.001;
	    const heatpumpIndex = NodeUtils.findNodeIndex("Thermal Energy Demand");
	    const buildingIndex = NodeUtils.findNodeIndex("Building");
	    const sinkNodeIndex = NodeUtils.findNodeIndex("M.2.1.S Sink (Air/Ground)");
	    const electricNodeIndex = NodeUtils.findNodeIndex("M.2.1.D Energy Input");
	    const gasExhaustIndex = NodeUtils.findNodeIndex("GasExhaust");

	    const currentCOPh = StateManager.getValue("copHeating");
	    console.log("Current COP/Efficiency:", currentCOPh);

	    if (isGasHeating) {
	      const spaceHeatingDemand = Math.max(minValue, requiredOutput);
	      const spaceHeatingInput = spaceHeatingDemand / currentCOPh;
	      const spaceHeatingOutput = spaceHeatingDemand;
	      const spaceHeatingLoss = spaceHeatingInput - spaceHeatingOutput;
	      const tedExhaust = Math.max(minValue, spaceHeatingLoss);

	      console.log("=== Gas Mode Debug ===");
	      console.log("Node indices:", {
	        heatpump: heatpumpIndex,
	        gasExhaust: gasExhaustIndex,
	        nodeNames: data.nodes.map((n) => n.name),
	      });
	      console.log("Link values:", {
	        demand: spaceHeatingDemand,
	        input: spaceHeatingInput,
	        loss: spaceHeatingLoss,
	        tedExhaust: tedExhaust,
	      });
	      console.log(
        "Existing link:",
        LinkUtils.findLink(heatpumpIndex, gasExhaustIndex),
      );

	      M21D = spaceHeatingInput;
	      TED = spaceHeatingOutput;
	      M21S = 0;

	      const gasExhaustNode = data.nodes[gasExhaustIndex];
	      if (gasExhaustNode) {
	        gasExhaustNode.hidden = false;
	        gasExhaustNode.color = "#BE343D";
	      }

	      const targetLinks = [
	        {
          source: electricNodeIndex,
          target: heatpumpIndex,
          value: spaceHeatingInput,
        },
	        {
          source: heatpumpIndex,
          target: buildingIndex,
          value: spaceHeatingOutput,
        },
	        { source: heatpumpIndex, target: gasExhaustIndex, value: tedExhaust },
	        { source: sinkNodeIndex, target: heatpumpIndex, value: minValue },
	      ];

	      targetLinks.forEach((link) => {
	        LinkUtils.updateLink(link.source, link.target, link.value, false);
	      });
	    } else {
	      TED = Math.max(minValue, requiredOutput);
	      M21D = TED / currentCOPh;
	      M21S = TED - M21D;

	      console.log("Heat pump mode calculations:", {
	        TED,
	        M21D,
	        M21S,
	        COP: currentCOPh,
	      });

	      const gasExhaustNode = data.nodes[gasExhaustIndex];
	      if (gasExhaustNode) {
	        gasExhaustNode.hidden = true;
	      }

	      const targetLinks = [
	        { source: sinkNodeIndex, target: heatpumpIndex, value: M21S },
	        { source: electricNodeIndex, target: heatpumpIndex, value: M21D },
	        { source: heatpumpIndex, target: buildingIndex, value: TED },
	        { source: heatpumpIndex, target: gasExhaustIndex, value: minValue },
	      ];

	      targetLinks.forEach((link) => {
	        LinkUtils.updateLink(link.source, link.target, link.value, false);
	      });
	    }

	    this.updateSHWSystem();
	  },

	  updateSHWSystem() {
	    const minValue = 0.001;
	    const shwIndex = NodeUtils.findNodeIndex("W.5.2 SHW Net Demand");
	    const buildingIndex = NodeUtils.findNodeIndex("Building");
	    const gasExhaustIndex = NodeUtils.findNodeIndex("GasExhaust");

	    // Get current DHW demand value
	    const dhwDemand =
      LinkUtils.getLinkValue("W.5.2 SHW Net Demand", "Building") || minValue;

	    if (isGasHeating) {
	      const efficiency = StateManager.getValue("copHeating");
	      const dhwInput = dhwDemand / efficiency;
	      const dhwLoss = dhwInput - dhwDemand;
	      const shwExhaust = Math.max(minValue, dhwLoss);

	      console.log("SHW Gas mode flows:", {
	        demand: dhwDemand,
	        input: dhwInput,
	        loss: dhwLoss,
	        exhaust: shwExhaust,
	      });

	      LinkUtils.updateLink(shwIndex, buildingIndex, dhwDemand, false);
	      LinkUtils.updateLink(shwIndex, gasExhaustIndex, shwExhaust, false);
	      LinkUtils.updateLink(
        buildingIndex,
        NodeUtils.findNodeIndex("W.2.W SHW Wasted"),
        dhwDemand,
        false,
      );
	    } else {
	      LinkUtils.updateLink(shwIndex, buildingIndex, dhwDemand, false);
	      LinkUtils.updateLink(shwIndex, gasExhaustIndex, minValue, false);
	      LinkUtils.updateLink(
        buildingIndex,
        NodeUtils.findNodeIndex("W.2.W SHW Wasted"),
        dhwDemand,
        false,
      );
	    }
	  },

	  updateSHW(sourceName, targetName, newValue) {
	    const buildingIndex = NodeUtils.findNodeIndex("Building");
	    const minValue = 0.001;

	    // Store this new value as the original/base value for DWHR calculations
	    if (sourceName === "W.5.2 SHW Net Demand") {
	      const demandLink = LinkUtils.findLink(
	        NodeUtils.findNodeIndex("W.5.2 SHW Net Demand"),
	        buildingIndex,
	      );
	      if (demandLink) {
	        demandLink.originalValue = newValue;
	      }

	      // If DWHR is active, apply it to the new base value
	      const dwhrEfficiency = StateManager.getValue("dwhrEfficiency");
	      const adjustedValue = Math.max(minValue, newValue * (1 - dwhrEfficiency));

	      // Update both demand and waste links
	      LinkUtils.updateLink(
	        NodeUtils.findNodeIndex("W.5.2 SHW Net Demand"),
	        buildingIndex,
	        adjustedValue,
	        false,
	      );
	      LinkUtils.updateLink(
	        buildingIndex,
	        NodeUtils.findNodeIndex("W.2.W SHW Wasted"),
	        adjustedValue,
	        false,
	      );

	      // Update system state
	      this.updateSHWSystem();
	      // Recalculate energy balance
	      this.updateBuildingBalance();
	    }
	  },

	  calculateEnergyBalance() {
	    const G12 = LinkUtils.getLinkValue("G.1.2 Occupant Gains", "Building");
	    const G2 = LinkUtils.getLinkValue("G.2 Plug Light Equipment", "Building");
	    const G1 = [
      "G.8.1 Windows N",
      "G.8.2 Windows E",
	      "G.8.3 Windows S",
      "G.8.4 Windows W",
      "G.8.5 Skylights",
	      "G.7.0 Doors",
    ].reduce((sum, source) => {
	      return sum + LinkUtils.getLinkValue(source, "Building");
	    }, 0);
	    const totalPassiveGains = G12 + G2 + G1;

	    const TEL = LinkUtils.getLinkValue("Building", "Total Envelope Losses");
	    const V23 = LinkUtils.getLinkValue(
      "Building",
      "V.2.3 Unrecovered Ventilation",
    );
	    const totalLosses = TEL + V23;

	    const gainsFactorMethod =
      document.getElementById("gainsFactorMethod").value;
	    let usableGains, nGainsFactor;

	    if (gainsFactorMethod === "phpp") {
	      const ratio = totalPassiveGains / totalLosses;
	      nGainsFactor = (1 - Math.pow(ratio, 5)) / (1 - Math.pow(ratio, 6));
	      usableGains = totalPassiveGains * nGainsFactor;
	      calculatedRatio = ratio;
	    } else {
	      nGainsFactor = parseFloat(gainsFactorMethod) || 0.6;
	      usableGains = totalPassiveGains * nGainsFactor;
	      calculatedRatio = null;
	    }

	    const G5 = Math.max(0.1, totalPassiveGains - usableGains);
	    const TED = Math.max(0.1, totalLosses - usableGains);

	    return {
	      totalPassiveGains,
	      totalLosses,
	      usableGains,
	      G5,
	      TED,
	      nGainsFactor,
	    };
	  },

	  updateBuildingBalance() {
	    const balance = this.calculateEnergyBalance();
	    TED = balance.TED;
	    this.updateHeatPumpValues(balance.TED);

	    LinkUtils.updateLink(
	      NodeUtils.findNodeIndex("Building"),
	      NodeUtils.findNodeIndex("G.5 Unusable Gains"),
	      balance.G5,
	      true,
	    );
	  },

	  updateMVHR(newEfficiency) {
	    const v23Link = LinkUtils.findLink(
	      NodeUtils.findNodeIndex("Building"),
	      NodeUtils.findNodeIndex("V.2.3 Unrecovered Ventilation"),
	    );

	    if (!v23Link) return;
	    v23Link.originalValue = v23Link.originalValue || v23Link.value;
	    const newValue = Math.max(0.1, v23Link.originalValue * (1 - newEfficiency));

	    LinkUtils.updateLink(
	      NodeUtils.findNodeIndex("Building"),
	      NodeUtils.findNodeIndex("V.2.3 Unrecovered Ventilation"),
	      newValue,
	      true,
	    );

	    this.updateBuildingBalance();
	  },

	  updateDWHR(newEfficiency) {
	    const buildingIndex = NodeUtils.findNodeIndex("Building");
	    const links = {
	      demand: LinkUtils.findLink(
        NodeUtils.findNodeIndex("W.5.2 SHW Net Demand"),
        buildingIndex,
      ),
	      waste: LinkUtils.findLink(
        buildingIndex,
        NodeUtils.findNodeIndex("W.2.W SHW Wasted"),
      ),
	    };

	    if (!links.demand || !links.waste) return;
	    links.demand.originalValue =
      links.demand.originalValue || links.demand.value;
	    const baseValue = links.demand.originalValue;
	    const newValue = Math.max(0.1, baseValue * (1 - newEfficiency));

	    LinkUtils.updateLink(
	      NodeUtils.findNodeIndex("W.5.2 SHW Net Demand"),
	      buildingIndex,
	      newValue,
	      true,
	    );
	    LinkUtils.updateLink(
	      buildingIndex,
	      NodeUtils.findNodeIndex("W.2.W SHW Wasted"),
	      newValue,
	      true,
	    );
	  },

	  updateTEL(isInitialLoad = false) {
	    const telIndex = NodeUtils.findNodeIndex("Total Envelope Losses");
	    const buildingIndex = NodeUtils.findNodeIndex("Building");

	    const telComponents = [
	      "B.4 Roof",
      "B.5 Walls Above Grade",
      "B.6 Floor Exposed",
      "B.7.0 Doors",
	      "B.8.1 Windows N",
      "B.8.2 Windows E",
      "B.8.3 Windows S",
      "B.8.4 Windows W",
      "B.8.5 Skylights",
	      "B.10 Floor Slab",
      "B.12 TB Penalty",
      "B.18.3 Air Leakage",
	    ];

	    const telTotal = telComponents.reduce((sum, component) => {
	      const value = LinkUtils.getLinkValue("Total Envelope Losses", component);
	      return sum + value;
	    }, 0);

	    LinkUtils.updateLink(buildingIndex, telIndex, telTotal, isInitialLoad);

	    LinkUtils.verifyNodeReferences();

	    if (!isInitialLoad) {
	      this.updateBuildingBalance();
	    }
	  },

	  calculateElementHeatLoss(componentKey, elementArea, rsiValue) {
	    const component = CONFIG.BUILDING_ELEMENTS.COMPONENTS[componentKey];
	    if (!component) {
	      console.error(`Component configuration not found for ${componentKey}`);
	      return 0.001;
	    }

	    if (elementArea <= 0.001) {
	      return 0.001;
	    }

	    const area = Number(
      parseFloat(
        elementArea ||
	          StateManager.getValue(`${componentKey.toLowerCase()}Area`) ||
	          component.elementArea.default,
      ).toFixed(this.PRECISION.AREA),
    );

	    const rsi = parseFloat(
      rsiValue ||
	        StateManager.getValue(`${componentKey.toLowerCase()}Rsi`) ||
	        component.rsi.default,
    );

	    const degreedays = Math.round(
      component.type === "GROUND_FACING"
	        ? StateManager.getValue("groundFacingHeatingDegreeDays") ||
            CONFIG.BUILDING_ELEMENTS.GFHDD.default
	        : StateManager.getValue("heatingDegreeDays") ||
            CONFIG.BUILDING_ELEMENTS.HDD.default,
    );

	    const intermediate = area * (degreedays * 24);
	    const divisor = rsi * 1000;
	    const heatLoss = (intermediate / divisor).toFixed(2);

	    return Math.max(0.001, parseFloat(heatLoss));
	  },
	};
</script>	
<!-- Script Block 5: D3 Visualization System -->
<script defer>
	// Script Block 5: D3 Sankey Visualization
	const SankeyDiagram = {
	  svg: d3.select("#sankey"),
	  tooltip: d3.select("#tooltip"),
	  sankey: d3
    .sankey()
	    .nodeWidth(20)
	    .nodePadding(15)
	    .extent([
      [1, 1],
      [1100 - 1, 600 - 1],
    ]),

	  initialize() {
	    this.linkGroup = this.svg.append("g").attr("class", "links");
	    this.nodeGroup = this.svg.append("g").attr("class", "nodes");
	    this.labelGroup = this.svg.append("g").attr("class", "labels");
	  },

	  // Replace both render and renderLinks methods in SankeyDiagram object
	  render(isInitialLoad = false) {
	    if (!data.nodes || !data.links) {
	      console.error("Invalid data structure:", data);
	      updateStatus("Error: Invalid data structure", "error");
	      return;
	    }

	    // NEW CODE
	    // Validate all links before rendering
	    const validatedLinks = LinkUtils.ensureValidLinkStructure();
	    // END NEW CODE

	    if (showEmissions) {
	      this.updateEmissionsFlows();
	    }

	    try {
	      // Ensure nodes are properly indexed
	      data.nodes.forEach((node, index) => {
	        node.index = index;
	      });

	      // MODIFIED: Use validatedLinks in working copy
	      const workingData = {
	        nodes: data.nodes,
	        links: validatedLinks
          .map((l) => ({
	            source: typeof l.source === "object" ? l.source.index : l.source,
	            target: typeof l.target === "object" ? l.target.index : l.target,
	            value: l.value,
	            isEmissions: l.isEmissions,
	          }))
          .filter((l) => l.source !== undefined && l.target !== undefined),
	      };

	      // Debug output
	      console.log("Rendering Sankey with validated data:", {
	        g5Link: workingData.links.find(
          (l) =>
	            (typeof l.source === "number"
              ? data.nodes[l.source].name
              : l.source.name) === "Building" &&
            (typeof l.target === "number"
              ? data.nodes[l.target].name
              : l.target.name) === "G.5 Unusable Gains",
	        ),
	        tedLinks: workingData.links.filter(
          (l) =>
	            (typeof l.source === "number"
              ? data.nodes[l.source].name
              : l.source.name) === "Thermal Energy Demand" ||
	            (typeof l.target === "number"
              ? data.nodes[l.target].name
              : l.target.name) === "Thermal Energy Demand",
	        ),
	      });

	      const { nodes, links } = this.sankey(workingData);

	      nodes.forEach((node) => {
	        node.displayColor = d3.color(node.color).darker(0.3);
	      });

	      const maxX = d3.max(nodes, (d) => d.x0);
	      this.renderLinks(links, isInitialLoad, maxX);
	      this.renderNodes(nodes, isInitialLoad, maxX);
	      this.renderLabels(nodes, isInitialLoad, maxX);
	    } catch (error) {
	      console.error("Error rendering chart:", error, "\nData:", workingData);
	      updateStatus("Error rendering chart: " + error.message, "error");
	    }
	  },

	  renderLinks(links, isInitialLoad, maxX) {
	    const link = this.linkGroup.selectAll(".link").data(links, (d) => {
	      const sourceIndex =
        typeof d.source === "number" ? d.source : data.nodes.indexOf(d.source);
	      const targetIndex =
        typeof d.target === "number" ? d.target : data.nodes.indexOf(d.target);
	      return `${sourceIndex}-${targetIndex}`;
	    });

	    link.exit().remove();

	    const linkEnter = link
      .enter()
	      .append("path")
	      .attr("class", "link")
	      .style("stroke-opacity", 0)
	      .attr("stroke-width", 0)
	      .on("mouseover", (event, d) => this.showLinkTooltip(event, d))
	      .on("mouseout", () => this.hideTooltip());

	    const linkUpdate = link
      .merge(linkEnter)
	      .style("stroke", (d) => this.getLinkColor(d));

	    if (isInitialLoad) {
	      linkUpdate
	        .attr("d", d3.sankeyLinkHorizontal())
	        .style("stroke-opacity", 0)
	        .attr("stroke-width", 0)
	        .transition()
	        .duration(750)
	        .delay((d) => (d.source.x0 / maxX) * 1500)
	        .style("stroke-opacity", 0.7)
	        .transition()
	        .duration(500)
	        .attr("stroke-width", (d) => Math.max(1, d.width));
	    } else {
	      linkUpdate
	        .transition()
	        .duration(750)
	        .attr("d", d3.sankeyLinkHorizontal())
	        .style("stroke-opacity", 0.7)
	        .attr("stroke-width", (d) => Math.max(1, d.width));
	    }
	  },

	  // Inside the SankeyDiagram object, modify renderLinks and renderNodes:

	  renderNodes(nodes, isInitialLoad, maxX) {
	    const node = this.nodeGroup.selectAll(".node").data(nodes, (d) => d.name);

	    node.exit().transition().duration(500).attr("width", 0).remove();

	    const nodeEnter = node
      .enter()
	      .append("rect")
	      .attr("class", "node")
	      .style("fill", (d) => d.displayColor)
	      .style("fill-opacity", 1)
	      .on("mouseover", (event, d) => this.showNodeTooltip(event, d))
	      .on("mouseout", () => this.hideTooltip());

	    const nodeUpdate = node.merge(nodeEnter);

	    if (isInitialLoad) {
	      // Initial state
	      nodeUpdate
	        .attr("x", (d) => d.x0)
	        .attr("y", (d) => d.y0)
	        .attr("height", (d) => d.y1 - d.y0)
	        .attr("width", 0)
	        .style("opacity", 0);

	      // Animated entrance
	      nodeUpdate
	        .transition()
	        .duration(750)
	        .delay((d) => (d.x0 / maxX) * 1500) // Delay based on x position
	        .style("opacity", 1)
	        .transition()
	        .duration(500)
	        .attr("width", (d) => d.x1 - d.x0);
	    } else {
	      // Regular update
	      nodeUpdate
	        .transition()
	        .duration(750)
	        .attr("x", (d) => d.x0)
	        .attr("y", (d) => d.y0)
	        .attr("height", (d) => d.y1 - d.y0)
	        .attr("width", (d) => d.x1 - d.x0);
	    }
	  },

	  renderLinks(links, isInitialLoad, maxX) {
	    const link = this.linkGroup.selectAll(".link").data(links, (d) => {
	      const source = NodeUtils.getSourceNodeIndex(d);
	      const target = NodeUtils.getTargetNodeIndex(d);
	      return `${source}-${target}`;
	    });

	    link.exit().transition().duration(500).attr("stroke-width", 0).remove();

	    const linkEnter = link
      .enter()
	      .append("path")
	      .attr("class", "link")
	      .style("stroke-opacity", 0)
	      .attr("stroke-width", 0)
	      .on("mouseover", (event, d) => this.showLinkTooltip(event, d))
	      .on("mouseout", () => this.hideTooltip());

	    const linkUpdate = link
      .merge(linkEnter)
	      .style("stroke", (d) => this.getLinkColor(d));

	    if (isInitialLoad) {
	      // Set initial path
	      linkUpdate
	        .attr("d", d3.sankeyLinkHorizontal())
	        .style("stroke-opacity", 0)
	        .attr("stroke-width", 0);

	      // Animate the flow
	      linkUpdate
	        .transition()
	        .duration(750)
	        .delay((d) => (d.source.x0 / maxX) * 1500) // Match node timing
	        .style("stroke-opacity", 0.7)
	        .transition()
	        .duration(500)
	        .attr("stroke-width", (d) => Math.max(1, d.width));
	    } else {
	      // Regular update
	      linkUpdate
	        .transition()
	        .duration(750)
	        .attr("d", d3.sankeyLinkHorizontal())
	        .style("stroke-opacity", 0.7)
	        .attr("stroke-width", (d) => Math.max(1, d.width));
	    }
	  },

	  renderLabels(nodes, isInitialLoad, maxX) {
	    const label = this.labelGroup
      .selectAll(".node-label")
	      .data(nodes, (d) => d.name);

	    label.exit().transition().duration(500).style("opacity", 0).remove();

	    const labelEnter = label
      .enter()
	      .append("text")
	      .attr("class", "node-label")
	      .style("opacity", 0);

	    const labelUpdate = label
      .merge(labelEnter)
	      .attr("x", (d) => (d.x0 < 1100 / 2 ? d.x1 + 5 : d.x0 - 5))
	      .attr("y", (d) => (d.y0 + d.y1) / 2)
	      .attr("text-anchor", (d) => (d.x0 < 1100 / 2 ? "start" : "end"))
	      .text((d) => this.formatNodeLabel(d));

	    if (isInitialLoad) {
	      labelUpdate
	        .transition()
	        .duration(750)
	        .delay((d) => (d.x0 / maxX) * 1500 + 500) // Slightly delayed after node appears
	        .style("opacity", 1);
	    } else {
	      labelUpdate.transition().duration(750).style("opacity", 1);
	    }
	  },
	
	  showNodeTooltip(event, d) {
	    const content = this.createNodeTooltip(d);
	    this.showTooltip(content, event);
	    d3.select(event.target).style("fill-opacity", 0.8);
	  },

	  showLinkTooltip(event, d) {
	    const content = this.createLinkTooltip(d);
	    this.showTooltip(content, event);
	    d3.select(event.target).style("stroke-opacity", 0.9);
	  },

	  createNodeTooltip(d) {
	    const incoming = data.links.filter(
      (l) => NodeUtils.getTargetNodeIndex(l) === d.index,
    );
	    const outgoing = data.links.filter(
      (l) => NodeUtils.getSourceNodeIndex(l) === d.index,
    );

	    let html = `<div class="tooltip-title">${d.name}</div>`;

	    if (d.name.includes("Emissions")) {
	      const totalEmissions = incoming.reduce(
        (sum, link) => sum + link.value,
        0,
      );
	      const mtValue = (totalEmissions / 1000000).toFixed(2); // Force 2 decimals
	      const scope = d.name.includes("1")
        ? "Direct emissions from gas combustion"
        : "Indirect emissions from electricity use";
	      html += `
		      <div class="tooltip-value">
		        Total: ${mtValue} MT CO2e
		        <br><small>${scope}</small>
		      </div>`;
	    } else {
	      html += `<div class="tooltip-value">Total Value: ${this.formatValue(d.value)}</div>`;
	    }

	    if (incoming.length > 0)
      html += this.buildFlowSection("Incoming", incoming, true);
	    if (outgoing.length > 0)
      html += this.buildFlowSection("Outgoing", outgoing, false);

	    return html;
	  },

	  createLinkTooltip(d) {
	    return `
		    <div class="tooltip-title">Flow Details</div>
		    <div class="tooltip-flow"><span>From: ${d.source.name}</span></div>
		    <div class="tooltip-flow"><span>To: ${d.target.name}</span></div>
		    <div class="tooltip-flow"><span>Value: ${
        d.isEmissions
          ? `${d.value.toFixed(2)} grams CO2e`
          : `${d.value.toFixed(2)} kWh`
      }</span></div>
		  `;
	  },

	  buildFlowSection(title, flows, isIncoming) {
	    let html = `<div style="margin-top: 8px;"><strong>${title}:</strong></div>`;
	    flows.forEach((flow) => {
	      const nodeName = isIncoming
        ? data.nodes[NodeUtils.getSourceNodeIndex(flow)].name
	        : data.nodes[NodeUtils.getTargetNodeIndex(flow)].name;
	      // Add line break between node name and value
	      html += `
		      <div class="tooltip-flow">
		        <span style="width: 160px;">${nodeName}</span>
		        <span>${
            flow.isEmissions
              ? `${(flow.value / 1000).toFixed(2)} kg CO2e`
              : `${flow.value.toFixed(2)} kWh`
          }</span>
		      </div>`;
	    });
	    return html;
	  },

	  formatValue(value) {
	    return `${value.toFixed(2)} kWh`;
	  },

	  // Tooltip and Label Formatting
	  formatNodeLabel(node) {
	    if (node.name.includes("Emissions")) {
	      const totalEmissions =
        node.targetLinks?.reduce((sum, link) => sum + link.value, 0) || 0;
	      const mtValue = (totalEmissions / 1000000).toFixed(2); // Force 2 decimals
	      return `${node.name} (${mtValue} MT)`;
	    }
	    return node.name;
	  },

	  showTooltip(content, event) {
	    const padding = 10;
	    this.tooltip
	      .style("display", "block")
	      .style("left", `${event.pageX + padding}px`)
	      .style("top", `${event.pageY + padding}px`)
	      .html(content);

	    const tooltipRect = this.tooltip.node().getBoundingClientRect();
	    const viewportWidth = window.innerWidth;
	    const viewportHeight = window.innerHeight;

	    // Adjust position if tooltip goes off screen
	    if (tooltipRect.right > viewportWidth) {
	      this.tooltip.style(
        "left",
        `${event.pageX - tooltipRect.width - padding}px`,
      );
	    }
	    if (tooltipRect.bottom > viewportHeight) {
	      this.tooltip.style(
        "top",
        `${event.pageY - tooltipRect.height - padding}px`,
      );
	    }
	  },

	  hideTooltip() {
	    this.tooltip.style("display", "none");
	  },

	  getLinkColor(d) {
	    // Special case for exhaust flows
	    if (d.target.name === "GasExhaust") {
	      return "#BE343D"; // Always make exhaust flows red
	    }

	    if (d.source.name === "Building" || d.target.name === "Building") {
	      return d.source.name === "Building"
	        ? d3.color(d.target.color).brighter(0.2)
	        : d3.color(d.source.color);
	    }
	    return d3.interpolateRgb(d.source.color, d.target.color)(0.5);
	  },
	
	  calculateElectricalEmissions(gridIntensity, scope2NodeIndex) {
	    const isGasSystem = StateManager.getValue("heatingSystem") === "Gas";
	    console.log("Starting electrical emissions calculation");

	    // G2 is always electrical
	    const g2Value = LinkUtils.getLinkValue(
      "G.2 Plug Light Equipment",
      "Building",
    );
	    console.log("G2 value:", g2Value, "kWh");
	    if (g2Value > 0.1) {
	      const g2Emissions = Math.round(g2Value * gridIntensity * 100) / 100;
	      console.log("G2 emissions:", g2Emissions, "grams CO2e");
	      if (g2Emissions > 0.1) {
	        data.links.push({
	          source: NodeUtils.findNodeIndex("G.2 Plug Light Equipment"),
	          target: scope2NodeIndex,
	          value: g2Emissions,
	          isEmissions: true,
	        });
	      }
	    }

	    if (!isGasSystem) {
	      const m21dValue = LinkUtils.getLinkValue(
        "M.2.1.D Energy Input",
        "Thermal Energy Demand",
      );
	      console.log("M21D value:", m21dValue, "kWh");
	      if (m21dValue > 0.1) {
	        const m21dEmissions = Math.round(m21dValue * gridIntensity * 100) / 100;
	        console.log("M21D emissions:", m21dEmissions, "grams CO2e");
	        if (m21dEmissions > 0.1) {
	          data.links.push({
	            source: NodeUtils.findNodeIndex("M.2.1.D Energy Input"),
	            target: scope2NodeIndex,
	            value: m21dEmissions,
	            isEmissions: true,
	          });
	        }
	      }

	      // Add SHW emissions in electric mode
	      const shwValue = LinkUtils.getLinkValue(
        "W.5.2 SHW Net Demand",
        "Building",
      );
	      console.log("SHW value:", shwValue, "kWh");
	      if (shwValue > 0.1) {
	        const shwEmissions = Math.round(shwValue * gridIntensity * 100) / 100;
	        console.log("SHW emissions:", shwEmissions, "grams CO2e");
	        if (shwEmissions > 0.1) {
	          data.links.push({
	            source: NodeUtils.findNodeIndex("W.5.2 SHW Net Demand"),
	            target: scope2NodeIndex,
	            value: shwEmissions,
	            isEmissions: true,
	          });
	        }
	      }
	    }
	    console.log("Completed electrical emissions calculation");
	  },

	  calculateHeatingEmissions(gridIntensity, scope1NodeIndex, scope2NodeIndex) {
	    if (!isGasHeating) return;

	    const heatingNodes = [
	      { name: "Thermal Energy Demand" },
	      { name: "W.5.2 SHW Net Demand" },
	    ];

	    // Calculate scope 1 emissions for each gas heating component
	    heatingNodes.forEach(({ name }) => {
	      const nodeIndex = NodeUtils.findNodeIndex(name);
	      if (nodeIndex === -1) return;

	      // Get total demand including losses
	      const flowValue = LinkUtils.getLinkValue(name, "Building");
	      const gasExhaustValue = LinkUtils.getLinkValue(name, "GasExhaust");
	      const totalGasEnergy = flowValue + gasExhaustValue;

	      if (totalGasEnergy > 0.1) {
	        const gasVolume =
          Math.round(
            (totalGasEnergy / CONFIG.EMISSIONS.GAS_ENERGY_DENSITY) * 1000,
          ) / 1000;
	        const emissionsValue =
          Math.round(gasVolume * CONFIG.EMISSIONS.GAS_INTENSITY * 100) / 100;

	        if (emissionsValue > 0.1) {
	          data.links.push({
	            source: nodeIndex,
	            target: scope1NodeIndex,
	            value: emissionsValue,
	            isEmissions: true,
	          });
	        }
	      }
	    });

	    // Add exhaust emissions from gas system
	    const exhaustValues = heatingNodes
      .map(({ name }) => LinkUtils.getLinkValue(name, "GasExhaust"))
	      .reduce((sum, val) => sum + val, 0);

	    if (exhaustValues > 0.1) {
	      const exhaustVolume =
        Math.round(
          (exhaustValues / CONFIG.EMISSIONS.GAS_ENERGY_DENSITY) * 1000,
        ) / 1000;
	      const exhaustEmissions =
        Math.round(exhaustVolume * CONFIG.EMISSIONS.GAS_INTENSITY * 100) / 100;

	      if (exhaustEmissions > 0.1) {
	        data.links.push({
	          source: NodeUtils.findNodeIndex("GasExhaust"),
	          target: scope1NodeIndex,
	          value: exhaustEmissions,
	          isEmissions: true,
	        });
	      }
	    }
	  },

	  updateEmissionsFlows() {
	    const scope1NodeIndex = NodeUtils.findNodeIndex("E1 Scope 1 Emissions");
	    const scope2NodeIndex = NodeUtils.findNodeIndex("E2 Scope 2 Emissions");

	    // Remove existing emissions flows
	    data.links = data.links.filter((link) => {
	      const targetIdx = NodeUtils.getTargetNodeIndex(link);
	      return targetIdx !== scope1NodeIndex && targetIdx !== scope2NodeIndex;
	    });

	    if (showEmissions) {
	      const gridIntensity =
        parseFloat(document.getElementById("gridIntensity").value) || 0;
	      // Handle electrical loads first
	      this.calculateElectricalEmissions(gridIntensity, scope2NodeIndex);
	      // Then handle heating and DHW emissions based on system type
	      this.calculateHeatingEmissions(
        gridIntensity,
        scope1NodeIndex,
        scope2NodeIndex,
      );
	    }
	  },

	  resize() {
	    const width = document.querySelector(".diagram-container").clientWidth;
	    const margin = { left: 20, right: 20 };
	    const innerWidth = width - margin.left - margin.right;

	    this.svg
	      .attr("width", width)
	      .attr("viewBox", `0 0 ${width} 600`)
	      .style("overflow", "visible");

	    this.sankey.extent([
      [margin.left, 1],
      [innerWidth - margin.right, 600 - 1],
    ]);
	    this.render(false);
	  },
	};
</script>
<!-- Script Block 6: User Interface Manager -->
<script defer>
	// Script Block 6: User Interface Manager
	const ControlPanel = {
	  updateAllComponentHeatLosses() {
	    console.log("=== Updating All Component Heat Losses ===");

	    // Update above-grade components with HDD
	    Object.keys(CONFIG.BUILDING_ELEMENTS.COMPONENTS)
	      .filter(
        (key) =>
          CONFIG.BUILDING_ELEMENTS.COMPONENTS[key].type === "ABOVE_GRADE",
      )
	      .forEach((componentKey) => {
	        const component = CONFIG.BUILDING_ELEMENTS.COMPONENTS[componentKey];
	        const area =
          StateManager.getValue(`${componentKey.toLowerCase()}Area`) ||
          component.elementArea.default;
	        const rsi =
          StateManager.getValue(`${componentKey.toLowerCase()}Rsi`) ||
          component.rsi.default;

        console.log(`Updating ${componentKey} - Area: ${area}, RSI: ${rsi}`);
	        const heatLoss = EnergyCalculator.calculateElementHeatLoss(
          componentKey,
          area,
          rsi,
        );
	        console.log(`New heat loss: ${heatLoss}`);

        LinkUtils.updateLinkByNames(
	          "Total Envelope Losses",
	          component.name,
	          heatLoss,
	        );
	      });

	    // Update ground-facing components with GFHDD
	    Object.keys(CONFIG.BUILDING_ELEMENTS.COMPONENTS)
	      .filter(
        (key) =>
          CONFIG.BUILDING_ELEMENTS.COMPONENTS[key].type === "GROUND_FACING",
      )
	      .forEach((componentKey) => {
	        const component = CONFIG.BUILDING_ELEMENTS.COMPONENTS[componentKey];
	        const area =
          StateManager.getValue(`${componentKey.toLowerCase()}Area`) ||
          component.elementArea.default;
	        const rsi =
          StateManager.getValue(`${componentKey.toLowerCase()}Rsi`) ||
          component.rsi.default;

        console.log(`Updating ${componentKey} - Area: ${area}, RSI: ${rsi}`);
	        const heatLoss = EnergyCalculator.calculateElementHeatLoss(
          componentKey,
          area,
          rsi,
        );
	        console.log(`New heat loss: ${heatLoss}`);

        LinkUtils.updateLinkByNames(
	          "Total Envelope Losses",
	          component.name,
	          heatLoss,
	        );
	      });

	    // Update overall TEL and energy balance
	    EnergyCalculator.updateTEL();
	    EnergyCalculator.updateBuildingBalance();
	  },

	  initialize() {
	    console.log("=== ControlPanel Init Start ===");

	    this.initializeControls();
	    this.bindEventListeners();
	    this.updateValueDisplays();
	    this.calculateTotalEnergyCost();
	    this.calculateTEUI();
	  },

	  initializeControls() {
	    if (!data?.nodes || !data?.links) {
	      console.error("Invalid data structure");
	      return;
	    }

	    const gainsBody = document.getElementById("gainsControlsBody");
	    const lossesBody = document.getElementById("lossesControlsBody");
	    gainsBody.innerHTML = "";
	    lossesBody.innerHTML = "";

	    // Update the headers for thermal properties
	    const controlsTable = document.querySelector(".controls-table");
	    if (controlsTable) {
	      const headerRow = controlsTable.querySelector("tr");
	      if (headerRow) {
	        // Update first header to be wider for component names
	        const firstHeader = headerRow.querySelector("th:first-child");
	        if (firstHeader) {
	          firstHeader.style.width = "220px";
	          firstHeader.style.minWidth = "220px";
	        }

        // Update second header for values
	        const secondHeader = headerRow.querySelector("th:nth-child(2)");
	        if (secondHeader) {
	          secondHeader.style.width = "60px";
	        }

        // Update third header width if needed
	        const thirdHeader = headerRow.querySelector("th:nth-child(3)");
	        if (thirdHeader) {
	          thirdHeader.style.width = "auto";
	        }
	      }
	    }

	    const buildingIndex = NodeUtils.findNodeIndex("Building");
	    const telIndex = NodeUtils.findNodeIndex("Total Envelope Losses");

	    // Process all gains (supply side)
	    data.links.forEach((link) => {
	      const sourceName = data.nodes[NodeUtils.getSourceNodeIndex(link)].name;
	      const targetName = data.nodes[NodeUtils.getTargetNodeIndex(link)].name;

      if (
	        targetName === "Building" ||
	        (sourceName === "M.2.1.S Sink (Air/Ground)" &&
          targetName === "Thermal Energy Demand") ||
	        (sourceName === "M.2.1.D Energy Input" &&
          targetName === "Thermal Energy Demand")
      ) {
	        this.createControlRow(
          gainsBody,
          link,
          sourceName,
          targetName,
	          DataManager.isCalculatedFlow(sourceName, targetName),
        );
	      }
	    });
	
	    this.addTotalsRow(gainsBody, true);

	    // Process all losses
	    data.links.forEach((link) => {
	      const sourceName = data.nodes[NodeUtils.getSourceNodeIndex(link)].name;
	      const targetName = data.nodes[NodeUtils.getTargetNodeIndex(link)].name;

      if (
	        (sourceName === "Total Envelope Losses" &&
          targetName.startsWith("B.")) ||
	        (sourceName === "Building" &&
          [
	            "Total Envelope Losses",
            "V.2.3 Unrecovered Ventilation",
	            "W.2.W SHW Wasted",
            "G.5 Unusable Gains",
          ].includes(targetName))
      ) {
	        this.createControlRow(
          lossesBody,
          link,
          sourceName,
          targetName,
	          DataManager.isCalculatedFlow(sourceName, targetName),
        );
	      }
	    });

	    this.addTotalsRow(lossesBody, false);
	    this.updateTotals();
	  },
	
	  addTotalsRow(tbody, isGains) {
	    const row = document.createElement("tr");
	    row.style.borderTop = "2px solid #ddd";

	    const nameCell = document.createElement("td");
	    nameCell.textContent = "Total";
	    nameCell.style.fontWeight = "bold";

	    const valueCell = document.createElement("td");
	    valueCell.style.fontWeight = "bold";
	    const totalSpan = document.createElement("span");
	    totalSpan.className = isGains ? "gains-total" : "losses-total";
	    totalSpan.style.padding = "4px 8px";
	    totalSpan.style.display = "inline-block";
	    valueCell.appendChild(totalSpan);

	    const controlCell = document.createElement("td");

	    row.append(nameCell, valueCell, controlCell);
	    tbody.appendChild(row);
	  },
	
	  updateTotals() {
	    // Calculate gains total
	    const gainsTotal = data.links.reduce((sum, link) => {
	      const sourceName = data.nodes[NodeUtils.getSourceNodeIndex(link)].name;
	      const targetName = data.nodes[NodeUtils.getTargetNodeIndex(link)].name;

	      // Include direct inputs to Building (except TED) plus M21S and M21D
	      if (
        (targetName === "Building" && sourceName !== "Thermal Energy Demand") || // Direct to Building
	        (targetName === "Thermal Energy Demand" && // Include M21S and M21D
	          ["M.2.1.S Sink (Air/Ground)", "M.2.1.D Energy Input"].includes(
            sourceName,
          ))
      ) {
	        return sum + link.value;
	      }
	      return sum;
	    }, 0);

	    // Calculate losses total (excluding TEL components)
	    const lossesTotal = data.links.reduce((sum, link) => {
	      const sourceName = data.nodes[NodeUtils.getSourceNodeIndex(link)].name;
	      const targetName = data.nodes[NodeUtils.getTargetNodeIndex(link)].name;

      // Include TEL components
	      if (
        (sourceName === "Total Envelope Losses" &&
          targetName.startsWith("B.")) || // All B.X components
	        (sourceName === "Building" &&
          [
            "V.2.3 Unrecovered Ventilation",
            "W.2.W SHW Wasted",
            "G.5 Unusable Gains",
          ].includes(targetName))
      ) {
	        return sum + link.value;
	      }
	      return sum;
	    }, 0);

	    // Update UI
	    const gainsTotalSpan = document.querySelector(".gains-total");
	    const lossTotalSpan = document.querySelector(".losses-total");

	    if (gainsTotalSpan) gainsTotalSpan.textContent = gainsTotal.toFixed(2);
	    if (lossTotalSpan) lossTotalSpan.textContent = lossesTotal.toFixed(2);

	    // Visual indicator if totals don't match
	    const mismatch = Math.abs(gainsTotal - lossesTotal) > 0.1;
	    if (gainsTotalSpan)
      gainsTotalSpan.style.color = mismatch ? "#ff0000" : "#000000";
	    if (lossTotalSpan)
      lossTotalSpan.style.color = mismatch ? "#ff0000" : "#000000";

	    // Make sure table shows M21S, M21D, and TED values
	    document.querySelectorAll(".value-display").forEach((display) => {
	      const sourceName = display.getAttribute("data-source");
	      const targetName = display.getAttribute("data-target");

	      let value = 0;
	      if (sourceName === "M.2.1.D Energy Input") {
	        value = M21D;
	      } else if (sourceName === "M.2.1.S Sink (Air/Ground)") {
	        value = M21S;
	      } else if (sourceName === "Thermal Energy Demand") {
	        value = TED;
	      } else {
	        value = LinkUtils.getLinkValue(sourceName, targetName);
	      }
	      display.textContent = value.toFixed(2);
	    });
	  },

	  createControlRow(tbody, link, sourceName, targetName, isCalculated) {
	    const row = document.createElement("tr");

	    // Name cell
	    const nameCell = document.createElement("td");
	    nameCell.textContent = `${sourceName} → ${targetName}`;

	    // Value cell
	    const valueCell = this.createValueCell(link, sourceName, targetName);

	    // Control cell (slider or calculated indicator)
	    const controlCell = isCalculated
	      ? this.createCalculatedCell()
      : this.createSliderCell(link, sourceName, targetName);

	    row.append(nameCell, valueCell, controlCell);
	    tbody.appendChild(row);
	  },

	  createValueCell(link, sourceName, targetName) {
	    const cell = document.createElement("td");
	    cell.style.width = "110px";

	    const display = document.createElement("span");
	    display.className = "value-display";
	    display.setAttribute("data-source", sourceName);
	    display.setAttribute("data-target", targetName);
	    display.textContent = link.value.toFixed(2);

	    const sourceColor = data.nodes.find((n) => n.name === sourceName).color;
	    const targetColor = data.nodes.find((n) => n.name === targetName).color;

	    cell.style.background = `linear-gradient(90deg, 
	      ${sourceColor}40 0%, 
	      ${targetColor}40 100%
	    )`;
	    cell.style.borderRadius = "3px";
	    cell.style.padding = "4px 8px";
	    cell.appendChild(display);

	    return cell;
	  },

	  createSliderCell(link, sourceName, targetName) {
	    const cell = document.createElement("td");
	    cell.className = "slider-cell";
	    // Check if this is a TEL component
	    if (
      sourceName === "Total Envelope Losses" &&
	      CONFIG.BUILDING_ELEMENTS.COMPONENTS[this.getComponentKey(targetName)]
    ) {
	      return this.createTELComponentControls(link, targetName);
	    }

	    const container = document.createElement("div");
	    container.style.display = "flex";
	    container.style.alignItems = "center";
	    container.style.gap = "8px";
	    container.style.height = "100%";

	    const slider = document.createElement("input");
	    slider.type = "range";
	    slider.min = "0";
	    slider.max = `${Math.max(link.value * 4, 300)}`;
	    slider.step = "0.001";
	    slider.value = link.value;
	    slider.style.width = "100px";

	    const input = document.createElement("input");
	    input.type = "number";
	    input.style.width = "120px";
	    input.style.padding = "2px 4px";
	    input.style.textAlign = "right";
	    input.style.appearance = "textfield";
	    input.step = "0.001";
	    input.value = link.value.toFixed(2);

	    slider.addEventListener("input", (e) => {
	      const newValue = parseFloat(e.target.value);
	      input.value = newValue.toFixed(2);

	      if (
        sourceName === "W.5.2 SHW Net Demand" ||
	        targetName === "W.2.W SHW Wasted"
      ) {
	        EnergyCalculator.updateSHW(sourceName, targetName, newValue);
	      }

	      this.updateValue(sourceName, targetName, newValue);
	    });

	    input.addEventListener("change", (e) => {
	      const newValue = parseFloat(e.target.value);
	      if (!isNaN(newValue)) {
	        slider.value = newValue;
	        if (
          sourceName === "W.5.2 SHW Net Demand" ||
	          targetName === "W.2.W SHW Wasted"
        ) {
	          EnergyCalculator.updateSHW(sourceName, targetName, newValue);
	        }
	        this.updateValue(sourceName, targetName, newValue);
	      }
	    });

	    container.appendChild(slider);
	    container.appendChild(input);
	    cell.appendChild(container);
	    return cell;
	  },

	  createCalculatedCell() {
	    const cell = document.createElement("td");
	    cell.className = "slider-cell";
	    cell.style.height = "32px";
	    cell.style.padding = "0 8px";
	    cell.style.display = "flex";
	    cell.style.alignItems = "center";

	    const label = document.createElement("em");
	    label.textContent = "Calculated";
	    label.style.color = "#666";
	    label.style.marginLeft = "8px";

	    cell.appendChild(label);
	    return cell;
	  },

	  // Add to ControlPanel object after createCalculatedCell()
	  getComponentKey(nodeName) {
	    return {
	      "B.4 Roof": "ROOF",
	      "B.5 Walls Above Grade": "WALLS_ABOVE_GRADE",
	      "B.6 Floor Exposed": "FLOOR_EXPOSED",
	      "B.7.0 Doors": "DOORS",
	      "B.8.1 Windows N": "WINDOWS_N",
	      "B.8.2 Windows E": "WINDOWS_E",
	      "B.8.3 Windows S": "WINDOWS_S",
	      "B.8.4 Windows W": "WINDOWS_W",
	      "B.8.5 Skylights": "SKYLIGHTS",
	      "B.9 Walls Below Grade": "WALLS_BELOW_GRADE",
	      "B.10 Floor Slab": "FLOOR_SLAB",
	    }[nodeName];
	  },
	
	  getComponentArea(targetName) {
	    const componentKey = this.getComponentKey(targetName);
	    const config = CONFIG.BUILDING_ELEMENTS.COMPONENTS[componentKey];
	    return (
      StateManager.getValue(`${componentKey.toLowerCase()}Area`) ||
      config.elementArea.default
    );
	  },

	  getComponentUValue(targetName) {
	    const componentKey = this.getComponentKey(targetName);
	    const config = CONFIG.BUILDING_ELEMENTS.COMPONENTS[componentKey];
	    return (
      StateManager.getValue(`${componentKey.toLowerCase()}UValue`) ||
      config.uValue.default
    );
	  },
	
	  // 2. Update ControlPanel - Modify createTELComponentControls method
	  createTELComponentControls(link, targetName) {
	    const cell = document.createElement("td");
	    cell.className = "slider-cell";
	    const componentKey = this.getComponentKey(targetName);

	    const container = document.createElement("div");
	    container.style.display = "flex";
	    container.style.gap = "16px";
	    container.style.alignItems = "center";

	    // Area control group (unchanged)
	    const areaGroup = document.createElement("div");
	    areaGroup.style.display = "flex";
	    areaGroup.style.alignItems = "center";
	    areaGroup.style.gap = "4px";
	    areaGroup.style.minWidth = "140px";

	    const areaSlider = document.createElement("input");
	    areaSlider.type = "range";
	    areaSlider.min = "0";
	    areaSlider.max = "1000";
	    areaSlider.step = "0.01";
	    areaSlider.value = this.getComponentArea(targetName);
	    areaSlider.style.width = "80px";
	    areaSlider.setAttribute("data-component", componentKey);
	    areaSlider.setAttribute("data-type", "area");

	    const areaInput = document.createElement("input");
	    areaInput.type = "number";
	    areaInput.style.width = "85px";
	    areaInput.step = "0.01";
	    areaInput.value =
      StateManager.getValue(`${componentKey.toLowerCase()}Area`) ?? //changed from || to ignore falsy values and return any 0 or 0.001 values and only default if null/undefined
	      this.getComponentArea(targetName);
	    areaInput.setAttribute("data-component", componentKey);
	    areaInput.setAttribute("data-type", "area");

	    const areaLabel = document.createElement("span");
	    areaLabel.textContent = ""; // Remove m² from here

	    // RSI/U-value control group
	    const thermalGroup = document.createElement("div");
	    thermalGroup.style.display = "flex";
	    thermalGroup.style.alignItems = "center";
	    thermalGroup.style.gap = "8px";
	    thermalGroup.style.minWidth = "200px";

	    // RSI input and label
	    const rsiDiv = document.createElement("div");
	    rsiDiv.style.display = "flex";
	    rsiDiv.style.alignItems = "center";
	    rsiDiv.style.gap = "4px";

	    const rsiLabel = document.createElement("span");
	    rsiLabel.textContent = ""; // Remove RSI from here

	    const rsiInput = document.createElement("input");
	    rsiInput.type = "number";
	    rsiInput.style.width = "50px";
	    rsiInput.step = "0.01";
	    rsiInput.min = "0.01";
	    rsiInput.value =
      StateManager.getValue(`${componentKey.toLowerCase()}Rsi`) ||
	      (1 / this.getComponentUValue(targetName)).toFixed(2);
	    rsiInput.setAttribute("data-component", componentKey);
	    rsiInput.setAttribute("data-type", "rsi");

	    // Common thermal resistance slider
	    const thermalSlider = document.createElement("input");
	    thermalSlider.type = "range";
	    thermalSlider.min = "0.01";
	    thermalSlider.max = "20";
	    thermalSlider.step = "0.01";
	    thermalSlider.value = rsiInput.value;
	    thermalSlider.style.width = "70px";
	    thermalSlider.setAttribute("data-component", componentKey);

	    // U-value input and label
	    const uValueDiv = document.createElement("div");
	    uValueDiv.style.display = "flex";
	    uValueDiv.style.alignItems = "center";
	    uValueDiv.style.gap = "4px";

	    const uValueLabel = document.createElement("span");
	    uValueLabel.textContent = ""; // Remove Uvalue: from here

	    const uValueInput = document.createElement("input");
	    uValueInput.type = "number";
	    uValueInput.style.width = "50px";
	    uValueInput.step = "0.001";
	    uValueInput.min = "0.001";
	    uValueInput.value = (1 / parseFloat(rsiInput.value)).toFixed(3);
	    uValueInput.setAttribute("data-component", componentKey);
	    uValueInput.setAttribute("data-type", "uvalue");
	    uValueInput.readOnly = false; // Make editable
	    uValueInput.addEventListener("change", (e) => {
	      const newUValue = parseFloat(e.target.value);
	      if (!isNaN(newUValue) && newUValue > 0) {
	        const newRsi = 1 / newUValue;
	        handleThermalUpdate(newRsi);
	      }
	    });

	    const unitLabel = document.createElement("span");
	    unitLabel.textContent = ""; // Remove W/m²·K from here

	    // In createTELComponentControls, modify display rounding:
	    const handleThermalUpdate = (newRsi) => {
	      const rsi = parseFloat(newRsi); // Keep full precision for calculation
	      const uValue = (1 / rsi).toFixed(3); // Round only for display

	      // Display with two decimal places but keep full precision internally
	      rsiInput.value = rsi.toFixed(2);
	      uValueInput.value = uValue;
	      thermalSlider.value = rsi;

	      const area = parseFloat(areaInput.value);
	      if (!isNaN(area) && !isNaN(rsi)) {
	        const heatLoss = EnergyCalculator.calculateElementHeatLoss(
	          componentKey,
	          area,
	          rsi, // Pass full precision value
	        );
	        LinkUtils.updateLinkByNames(
          "Total Envelope Losses",
          targetName,
          heatLoss,
        );
	        EnergyCalculator.updateTEL();
	        this.calculateTotalEnergyCost();
	        this.calculateTEUI();
	        this.updateValueDisplays();
	        SankeyDiagram.render(false);
	      }
	    };

	    // Event listeners
	    thermalSlider.addEventListener("input", (e) => {
	      handleThermalUpdate(e.target.value);
	    });

	    rsiInput.addEventListener("change", (e) => {
	      handleThermalUpdate(e.target.value);
	    });

	    areaSlider.addEventListener("input", (e) => {
	      areaInput.value = e.target.value;
	      handleThermalUpdate(rsiInput.value);
	    });

	    areaInput.addEventListener("change", (e) => {
	      areaSlider.value = e.target.value;
	      handleThermalUpdate(rsiInput.value);
	    });

	    // Assemble the controls
	    areaGroup.append(areaSlider, areaInput, areaLabel);
	    rsiDiv.append(rsiLabel, rsiInput);
	    uValueDiv.append(uValueLabel, uValueInput, unitLabel);
	    thermalGroup.append(rsiDiv, thermalSlider, uValueDiv);
	    container.append(areaGroup, thermalGroup);
	    cell.appendChild(container);

	    return cell;
	  },

	  // MODIFY existing updateValue method
	  updateValue(sourceName, targetName, newValue) {
	    const sourceIndex = NodeUtils.findNodeIndex(sourceName);
	    const targetIndex = NodeUtils.findNodeIndex(targetName);

	    LinkUtils.updateLink(sourceIndex, targetIndex, newValue);

	    if (sourceName === "Total Envelope Losses") {
	      EnergyCalculator.updateTEL();
	    }

	    EnergyCalculator.updateBuildingBalance();
	    this.updateValueDisplays();
	    this.updateTotals(); // NEW LINE
	    SankeyDiagram.render(false);
	    this.calculateTotalEnergyCost(); // RESTORE THIS LINE
	    this.calculateTEUI(); // RESTORE THIS LINE
	  },

	  updateValueDisplays() {
	    document.querySelectorAll(".value-display").forEach((display) => {
	      const sourceName = display.getAttribute("data-source");
	      const targetName = display.getAttribute("data-target");

	      let value = 0;
	      if (sourceName === "M.2.1.D Energy Input") {
	        value = M21D;
	      } else if (sourceName === "M.2.1.S Sink (Air/Ground)") {
	        value = M21S;
	      } else if (sourceName === "Thermal Energy Demand") {
	        value = TED;
	      } else {
	        value = LinkUtils.getLinkValue(sourceName, targetName);
	      }
	      display.textContent = value.toFixed(2);
	    });
	  },

	  calculateTotalEnergyCost() {
	    const electricityCost =
      parseFloat(document.getElementById("energyCost").value) ||
      CONFIG.EMISSIONS.DEFAULT_ELECTRICITY_COST;
	    const gasCost =
      parseFloat(document.getElementById("gasCost").value) ||
      CONFIG.EMISSIONS.DEFAULT_GAS_COST;
	    const gridIntensity =
      parseFloat(document.getElementById("gridIntensity").value) || 0;
	    const efficiency = StateManager.getValue("copHeating");

	    // Get electrical loads
	    const g2Value =
      LinkUtils.getLinkValue("G.2 Plug Light Equipment", "Building") || 0;
	    let electricalCost = g2Value * electricityCost;
	    let gasCostTotal = 0;

	    // Get thermal demands
	    const heatingDemand =
      LinkUtils.getLinkValue("Thermal Energy Demand", "Building") || 0;
	    const dhwDemand =
      LinkUtils.getLinkValue("W.5.2 SHW Net Demand", "Building") || 0;

	    if (isGasHeating) {
	      const totalGasEnergy = (heatingDemand + dhwDemand) / efficiency;
	      const gasVolume = totalGasEnergy / CONFIG.EMISSIONS.GAS_ENERGY_DENSITY;
	      gasCostTotal = gasVolume * gasCost;
	    } else {
	      const heatPumpElectrical = M21D || 0;
	      electricalCost += heatPumpElectrical * electricityCost;
	    }

	    // Calculate emissions
	    let totalEmissionsGrams = g2Value * gridIntensity;

	    if (isGasHeating) {
	      const gasVolume =
        (heatingDemand + dhwDemand) / CONFIG.EMISSIONS.GAS_ENERGY_DENSITY;
	      totalEmissionsGrams += gasVolume * CONFIG.EMISSIONS.GAS_INTENSITY;
	    } else {
	      const heatPumpElectrical = M21D || 0;
	      totalEmissionsGrams += heatPumpElectrical * gridIntensity;
	    }

	    const totalEmissionsMT = totalEmissionsGrams / 1000000;

	    try {
	      document.getElementById("electricityCostDisplay").textContent =
	        electricalCost.toLocaleString("en-US", {
	          minimumFractionDigits: 2,
	          maximumFractionDigits: 2,
	        });

	      document.getElementById("gasCostDisplay").textContent =
	        gasCostTotal.toLocaleString("en-US", {
	          minimumFractionDigits: 2,
	          maximumFractionDigits: 2,
	        });

	      document.getElementById("totalEnergyCost").textContent = (
	        electricalCost + gasCostTotal
      ).toLocaleString("en-US", {
	        minimumFractionDigits: 2,
	        maximumFractionDigits: 2,
	      });

	      document.getElementById("totalEmissions").textContent =
        totalEmissionsMT.toFixed(2);
	    } catch (error) {
	      console.error("Error updating cost/emissions displays:", error);
	    }
	  },

	  //Revised in 7r6 to represent purchased energy only
	  calculateTEUI() {
	    const area =
      parseFloat(document.getElementById("conditionedArea").value) || 528.0;

	    // Calculate purchased energy (plug loads + heat input + DHW)
	    const plugLoads =
      LinkUtils.getLinkValue("G.2 Plug Light Equipment", "Building") || 0;
	    const heatInput =
      LinkUtils.getLinkValue("M.2.1.D Energy Input", "Thermal Energy Demand") ||
      0;
	    const shwDemand =
      LinkUtils.getLinkValue("W.5.2 SHW Net Demand", "Building") || 0;

	    const purchasedEnergy = plugLoads + heatInput + shwDemand;
	    const teui = purchasedEnergy / area;
	    const teuiDisplay = document.getElementById("teuiValue");
	    if (teuiDisplay) {
	      teuiDisplay.textContent = teui.toFixed(2);
	    }

	    // Calculate TEDI
	    const ted =
      LinkUtils.getLinkValue("Thermal Energy Demand", "Building") || 0;
	    const tedi = ted / area;
	    const tediDisplay = document.getElementById("tediValue");
	    if (tediDisplay) {
	      tediDisplay.textContent = tedi.toFixed(2);
	    }

	    return teui;
	  },

	  bindEventListeners() {
	    // Energy cost input handlers
	    ["energyCost", "gasCost"].forEach((id) => {
	      const element = document.getElementById(id);
	      if (element) {
	        element.addEventListener("input", () => {
	          this.calculateTotalEnergyCost();
	        });
	      }
	    });
	
	    document
      .getElementById("gainsFactorMethod")
      ?.addEventListener("change", (e) => {
	        const selectedValue = e.target.value;
	        const calculatedDisplay = document.getElementById(
          "calculatedGainsFactor",
        );

        if (selectedValue === "phpp") {
	          // Get values for PHPP calculation
	          const G12 = LinkUtils.getLinkValue(
            "G.1.2 Occupant Gains",
            "Building",
          );
	          const G2 = LinkUtils.getLinkValue(
            "G.2 Plug Light Equipment",
            "Building",
          );
	          const G1 = [
            "G.8.1 Windows N",
            "G.8.2 Windows E",
	            "G.8.3 Windows S",
            "G.8.4 Windows W",
            "G.8.5 Skylights",
	            "G.7.0 Doors",
          ].reduce((sum, source) => {
	            return sum + LinkUtils.getLinkValue(source, "Building");
	          }, 0);
	          const T63 = LinkUtils.getLinkValue(
            "Building",
            "Total Envelope Losses",
          );
	          const V23 = LinkUtils.getLinkValue(
            "Building",
            "V.2.3 Unrecovered Ventilation",
          );
	
          // Calculate PHPP factor
	          const ratio = (G12 + G2 + G1) / (T63 + V23);
	          const factor = (1 - Math.pow(ratio, 5)) / (1 - Math.pow(ratio, 6));

          if (calculatedDisplay) {
	            calculatedDisplay.textContent = `(${(factor * 100).toFixed(2)}%)`; // Added .toFixed(2)
	          }
	          StateManager.setValue("nGainsFactor", factor);
	        } else {
	          const value = parseFloat(selectedValue);
	          if (!isNaN(value)) {
	            if (calculatedDisplay) {
	              calculatedDisplay.textContent = `(${(value * 100).toFixed(2)}%)`; // Added .toFixed(2)
	            }
	            StateManager.setValue("nGainsFactor", value);
	          }
	        }

        // Update the system
	        EnergyCalculator.updateBuildingBalance();
	        this.updateValueDisplays();
	        this.updateTotals();
	        SankeyDiagram.render(false);
	        this.calculateTotalEnergyCost();
	        this.calculateTEUI();
	      });
	
	    document
      .querySelector(".toggle-button")
      ?.addEventListener("click", function () {
	        const controls = document.querySelector(".efficiency-controls");
	        const isExpanded = controls.classList.contains("expanded");

        controls.classList.toggle("expanded");
	        controls.classList.toggle("collapsed");
	        this.classList.toggle("collapsed");

        // Trigger Sankey resize after animation
	        setTimeout(() => {
	          SankeyDiagram.resize();
	        }, 300);
	      });

	    // Add conditioned area input handler
	    document
      .getElementById("conditionedArea")
      ?.addEventListener("input", (e) => {
	        const value = parseFloat(e.target.value);
	        if (!isNaN(value)) {
	          StateManager.setValue("conditionedArea", value);
	          this.calculateTEUI();
	        }
	      });
	
	    //New HDD and Component Listeners
	    document
      .getElementById("heatingDegreeDays")
      ?.addEventListener("input", (e) => {
	        const value = parseFloat(e.target.value);
	        if (!isNaN(value)) {
	          console.log(`HDD event listener triggered with value: ${value}`);
	          StateManager.setValue("heatingDegreeDays", value);

          // Update all heat loss calculations
	          this.updateAllComponentHeatLosses();

          // Update building balance and displays
	          EnergyCalculator.updateBuildingBalance();
	          this.updateValueDisplays();
	          this.updateTotals();

          // Update derived calculations
	          this.calculateTotalEnergyCost();
	          this.calculateTEUI();

          // Render the updated diagram
	          SankeyDiagram.render(false);
	        }
	      });
	    //New GFHDD and Component Listeners
	    document
      .getElementById("groundFacingHeatingDegreeDays")
      ?.addEventListener("input", (e) => {
	        const value = parseFloat(e.target.value);
	        if (!isNaN(value)) {
	          StateManager.setValue("groundFacingHeatingDegreeDays", value);
	          this.updateAllComponentHeatLosses();
	          EnergyCalculator.updateBuildingBalance();
	          this.updateValueDisplays();
	          this.updateTotals();
	          this.calculateTotalEnergyCost();
	          this.calculateTEUI();
	          SankeyDiagram.render(false);
	        }
	      });

	    // Efficiency input handlers
	    [
      "gridIntensity",
      "copCooling",
      "copHeating",
	      "mvhrEfficiency",
      "dwhrEfficiency",
      "nGainsFactor",
    ].forEach((id) => {
	      const element = document.getElementById(id);
	      if (element) {
	        element.addEventListener("input", (e) => {
	          if (id === "copHeating") {
	            const value = parseFloat(e.target.value);
	            const isGasSystem =
              StateManager.getValue("heatingSystem") === "Gas";
	            if (isGasSystem) {
	              e.target.value = value.toFixed(2);
	              e.target.step = "0.01";
	            } else {
	              e.target.step = "0.01";
	            }
	          }
	          StateManager.setValue(id, parseFloat(e.target.value));
	          this.handleEfficiencyChange(e, id);
	        });
	      }
	    });

	    // Import handlers
	    document.getElementById("importButton")?.addEventListener("click", () => {
	      document.getElementById("csvFile").click();
	    });

	    document
      .getElementById("csvFile")
      ?.addEventListener("change", async (e) => {
	        const file = e.target.files[0];
	        if (file) await FileSystem.FileHandler.handleImport(file);
	      });

	    document
      .getElementById("applyButton")
      ?.addEventListener("click", this.handleApplyButtonClick.bind(this));

	    // Layout control handlers
	    document
      .getElementById("toggleSpacingButton")
      ?.addEventListener("click", function () {
	        spacingCollapsed = !spacingCollapsed;
	        SankeyDiagram.sankey.nodePadding(spacingCollapsed ? 0 : 15);
	        this.textContent = spacingCollapsed
          ? "Sankey Diagram"
          : "Energy Balance";
	        SankeyDiagram.render(false);
	      });

	    document.getElementById("widthMultiplier")?.addEventListener(
      "input",
      function (e) {
	        widthMultiplier = e.target.value / 100;
	        document.getElementById("widthValue").textContent =
          `${e.target.value}%`;
	        SankeyDiagram.sankey.nodeWidth(20 * widthMultiplier);
	        SankeyDiagram.render(false);
	      }.bind(this),
    );
	    document
      .getElementById("heatingSystem")
      ?.addEventListener("change", (e) => {
	        const newSystem = e.target.value;
	        StateManager.setValue("heatingSystem", newSystem);

        // Add explicit isGasHeating toggle
	        isGasHeating = newSystem === "Gas";
	        console.log("System change:", {
          newSystem,
	          isGasHeating,
	          currentCOP: StateManager.getValue("copHeating"),
	        });

	        const copHeatingInput = document.getElementById("copHeating");
	        const copHeatingLabel = document.getElementById("copHeatingLabel");

	        // Set appropriate efficiency/COP values
	        if (newSystem === "Gas") {
	          const newEfficiency = 0.9;
	          StateManager.setValue("copHeating", newEfficiency);
	        } else if (newSystem === "Electricity") {
	          const newEfficiency = 1.0;
	          StateManager.setValue("copHeating", newEfficiency);
	        } else {
	          // Heatpump mode
	          const defaultCOP = CONFIG.VALUE_LIMITS.COP_HEATING.default;
	          StateManager.setValue("copHeating", defaultCOP);
	        }

	        // Update UI elements
	        if (copHeatingInput && copHeatingLabel) {
	          copHeatingInput.value =
            StateManager.getValue("copHeating").toFixed(2);
	          copHeatingInput.min = newSystem === "Gas" ? "0.50" : "0.10";
	          copHeatingInput.max = newSystem === "Gas" ? "0.98" : "20.00";
	          copHeatingInput.step = "0.01";
	          copHeatingLabel.textContent =
            newSystem === "Gas" ? "Heat+SHW Efficiency" : "COP Heating";
	        }

	        // Update flows and display
	        EnergyCalculator.updateHeatPumpValues(TED);
	        EnergyCalculator.updateSHWSystem();
	        ControlPanel.updateValueDisplays();
	        ControlPanel.calculateTotalEnergyCost();

	        // Force emissions recalculation if emissions are showing
	        if (showEmissions) {
	          SankeyDiagram.updateEmissionsFlows();
	        }

	        SankeyDiagram.render(false);
	      });

	    // Updated Reset handler 3029r4
	    document.getElementById("resetButton")?.addEventListener(
      "click",
      function () {
	        try {
	          console.log("=== Reset Handler Start ===");

          // If we have an imported baseline, treat it like a new import
	          if (StateManager._importedBaseline) {
	            console.log("Resetting to imported baseline state");
	            pendingImportData = StateManager.getBaselineData();
	            this.handleApplyButtonClick();
	          } else {
	            console.log("No imported data found, resetting to defaults");
	            data = JSON.parse(JSON.stringify(originalData));
	            NodeUtils.ensureNodeReferences();
	            this.initializeControls();
	            EnergyCalculator.updateTEL(false);
	            EnergyCalculator.updateBuildingBalance();
	            this.calculateTotalEnergyCost();
	            this.calculateTEUI();
	            SankeyDiagram.render(true);
	          }

          console.log("=== Reset Handler Complete ===");
	        } catch (error) {
	          console.error("Error in reset handler:", error);
	          console.error(error.stack);
	          // Try to recover UI if there's an error
	          this.initializeControls();
	        }
	      }.bind(this),
	    );

    // Emissions handler
	    document
      .getElementById("toggleEmissionsButton")
      ?.addEventListener("click", function () {
	        showEmissions = !showEmissions;
	        this.textContent = showEmissions ? "Hide Emissions" : "Show Emissions";
	        SankeyDiagram.updateEmissionsFlows();
	        SankeyDiagram.render(false);
	      });
	  },

	  updateComponentControls(componentKey, updates) {
	    const selector = `input[data-component="${componentKey}"]`;
	    document.querySelectorAll(selector).forEach((input) => {
	      const type = input.getAttribute("data-type");
	      if (type === "area" && updates.area !== undefined) {
	        // Always use the imported value, even if it's 0
	        const formattedValue = parseFloat(updates.area).toFixed(2);
	        input.value = formattedValue;
	        // Also store original value to prevent defaulting
	        input.setAttribute("data-original-value", formattedValue);

        // Explicitly set the StateManager value
	        StateManager.setValue(
          `${componentKey.toLowerCase()}Area`,
          updates.area,
          "import",
        );
	
        // Trigger an input event to ensure calculations update
	        const event = new Event("input", { bubbles: true });
	        input.dispatchEvent(event);
	      }
	    });
	  },

	  handleEfficiencyChange(e, id) {
	    const value = parseFloat(e.target.value);
	    if (isNaN(value)) return;

	    switch (id) {
	      case "copHeating":
	        EnergyCalculator.updateHeatPumpValues(TED);
	        break;
	      case "mvhrEfficiency":
	        EnergyCalculator.updateMVHR(Math.max(0, Math.min(1, value)));
	        break;
	      case "dwhrEfficiency":
	        EnergyCalculator.updateDWHR(Math.max(0, Math.min(1, value)));
	        break;
	      case "nGainsFactor": // NEW CASE
	        EnergyCalculator.updateBuildingBalance();
	        break;
	    }

	    this.updateValueDisplays();
	    SankeyDiagram.render(false);
	    this.calculateTotalEnergyCost();
	    this.calculateTEUI();
	  },

	  // Modify the handleApplyButtonClick method in ControlPanel
	  handleApplyButtonClick() {
	    if (!pendingImportData) {
	      console.warn("No pending import data to apply");
	      updateStatus("No import data to apply", "error");
	      return;
	    }

	    try {
	      updateStatus("Applying import...", "pending");

	      // Create a backup before modifications
	      const backup = DataManager.backup();
	      console.log("Created backup:", backup);

	      // Flag to track if this is initial import vs user modification
	      const isInitialImport = true;

	      // Handle nodes and links first - direct application without recalculation
	      if (pendingImportData.nodes && pendingImportData.links) {
	        console.log("Directly applying node and link updates");
	        data = {
	          nodes: pendingImportData.nodes.map((node) => ({ ...node })),
	          links: pendingImportData.links.map((link) => ({ ...link })),
	        };
	        NodeUtils.ensureNodeReferences();
	      }

	      // Process global updates first
	      if (pendingImportData.globalUpdates) {
	        console.log(
          "Applying global updates:",
          pendingImportData.globalUpdates,
        );
	
        const inputMappings = {
	          ElectricityCost: "energyCost",
	          GasCost: "gasCost",
	          GridIntensity: "gridIntensity",
	          COPh: "copHeating",
	          COPc: "copCooling",
	          MVHR: "mvhrEfficiency",
	          DWHR: "dwhrEfficiency",
	          HDD: "heatingDegreeDays",
	          GFHDD: "groundFacingHeatingDegreeDays",
	          conditionedArea: "conditionedArea",
	        };

	        Object.entries(pendingImportData.globalUpdates).forEach(
          ([key, value]) => {
	            if (value !== undefined && value !== null) {
	              const elementId = inputMappings[key] || key.toLowerCase();
	              const element = document.getElementById(elementId);
	              if (element) {
	                console.log(`Updating ${elementId} to ${value}`);
	                element.value =
                  typeof value === "number" ? value.toFixed(2) : value;

                if (!isInitialImport) {
	                  const event = new Event("input", { bubbles: true });
	                  element.dispatchEvent(event);
	                }

                const stateKey = inputMappings[key] || key.toLowerCase();
	                StateManager.setValue(stateKey, value, "import");
	              }
	            }
	          },
        );
	      }

	      if (
        pendingImportData.componentUpdates &&
        pendingImportData.componentUpdates.size > 0
      ) {
	        console.log("Applying component updates");
	        const isImporting = true;

	        try {
	          pendingImportData.componentUpdates.forEach(
            (updates, componentName) => {
	              const componentKey = Object.keys(
                CONFIG.BUILDING_ELEMENTS.COMPONENTS,
	              ).find(
                (key) =>
                  CONFIG.BUILDING_ELEMENTS.COMPONENTS[key].name ===
                  componentName,
              );

              if (componentKey) {
	                // Debug state before update
	                console.log(`${componentKey} before update:`, {
	                  storedArea: StateManager.getValue(
                    `${componentKey.toLowerCase()}Area`,
                  ),
	                  storedUValue: StateManager.getValue(
                    `${componentKey.toLowerCase()}UValue`,
                  ),
	                  updateArea: updates.area,
	                  updateUValue: updates.uvalue,
	                });

	                if (updates.area !== undefined) {
	                  StateManager.setValue(
                    `${componentKey.toLowerCase()}Area`,
                    updates.area,
                    "import",
                  );
	                }
	                if (updates.uvalue !== undefined) {
	                  StateManager.setValue(
                    `${componentKey.toLowerCase()}UValue`,
                    updates.uvalue,
                    "import",
                  );
	                }

	                // Debug state after update
                console.log(`${componentKey} after update:`, {
	                  storedArea: StateManager.getValue(
                    `${componentKey.toLowerCase()}Area`,
                  ),
	                  storedUValue: StateManager.getValue(
                    `${componentKey.toLowerCase()}UValue`,
                  ),
	                });
	              }
	            },
          );
	        } catch (error) {
	          console.error("Error processing component updates:", error);
	        }
	      }

	      // These updates should always happen
	      this.initializeControls();
	      this.calculateTotalEnergyCost();
	      this.calculateTEUI();

      LinkUtils.verifyNodeReferences();
	      // Add our new balance step HERE, before the render:
	      // Recalculate energy balance after import
	      EnergyCalculator.updateTEL(false); // First update TEL from components
	      const balance = EnergyCalculator.calculateEnergyBalance();
	      if (!balance.isBalanced) {
	        console.log("Rebalancing energy after import");
	        EnergyCalculator.updateBuildingBalance();
	      }
	      SankeyDiagram.render(!isInitialImport);

	      // Final state verification
	      console.log("Final state verification:");
	      pendingImportData.componentUpdates.forEach((updates, componentName) => {
	        console.log(
          `${componentName} - Area: ${updates.area}, U-Value: ${updates.uvalue}`,
        );
	      });

	      pendingImportData = null;
	      document.getElementById("applyButton").style.display = "none";
	      updateStatus(
        "Import applied successfully - Note: Cooling Loads Excluded at this time.",
        "success",
      );
    } catch (error) {
	      console.error("Error applying import:", error);
	      updateStatus("Error applying import: " + error.message, "error");

	      try {
	        if (typeof backup !== "undefined" && backup) {
	          DataManager.restore(backup);
	          this.initializeControls();
	          SankeyDiagram.render(true);
	          updateStatus("Restored to previous state", "warning");
	        }
	      } catch (restoreError) {
	        console.error("Error during restore:", restoreError);
	        updateStatus("Error during restore: " + restoreError.message, "error");
	      }
	    }
	  },
	}; // End of ControlPanel object
</script>
<!-- Script Block 7: File Import/Export System -->
<script defer>
		const FileSystem = {
		  FileHandler: {
		    async handleImport(file) {
		      if (!file) {
		        updateStatus("No file selected", "error");
		        return;
		      }

		      try {
		        updateStatus("Processing import...", "pending");
		        pendingImportData = null;
		        document.getElementById("applyButton").style.display = "none";

		        const fileType = file.name.toLowerCase().split(".").pop();
		        let importedData;

		        if (fileType === "csv") {
		          importedData = await this.handleCSVImport(file);
		        } else if (fileType === "xlsx") {
		          importedData = await this.handleXLSXImport(file);
		        } else {
		          throw new Error("Please use a CSV or XLSX file");
		        }

		        if (importedData) {
		          StateManager.setImportedBaseline(importedData);
		          pendingImportData = importedData;
		          document.getElementById("applyButton").style.display = "inline-block";
		          document.getElementById("fileName").textContent = file.name;
		          updateStatus(
            "Import ready. Click Apply to update diagram.",
            "success",
          );
		        }
		      } catch (error) {
		        console.error("Import error:", error);
		        updateStatus(`Import failed: ${error.message}`, "error");
		        pendingImportData = null;
		        document.getElementById("applyButton").style.display = "none";
		      }
		    },
		
		    normalizeValue(value, type) {
		      if (value === undefined || value === null) return null;

      const numValue = parseFloat(value);
		      if (isNaN(numValue)) return null;

      switch (type) {
		        case "area":
		          return Number(numValue.toFixed(EnergyCalculator.PRECISION.AREA));
		        case "uvalue":
		          return Number(numValue.toFixed(EnergyCalculator.PRECISION.U_VALUE));
		        case "energy":
		          return Number(numValue.toFixed(EnergyCalculator.PRECISION.ENERGY));
		        case "degreedays":
		          return Math.round(numValue);
		        default:
		          return numValue;
		      }
		    },

		    async handleCSVImport(file) {
		      return new Promise((resolve, reject) => {
		        const reader = new FileReader();

		        reader.onload = (event) => {
		          try {
		            const csv = event.target.result;
		            const sections = csv.split("##").map((s) => s.trim());

		            const importedData = {
		              nodes: JSON.parse(JSON.stringify(originalData.nodes)),
		              links: JSON.parse(JSON.stringify(originalData.links)),
		              globalUpdates: {},
		              componentUpdates: new Map(),
		            };

		            const nodeLinks = sections.find((s) =>
              s.includes("Node and Link Alignment"),
            );
		            if (!nodeLinks) {
		              throw new Error("Node and Link Alignment section not found");
		            }

		            nodeLinks
              .split("\n")
		              .filter((line) => line.includes(",") && line.includes("["))
		              .forEach((line) => {
		                const parts = line.split(",").map((p) => p.trim());
		                const sourceMatch = parts[0].match(/\[(\d+)\]/);
		                const targetMatch = parts[1].match(/\[(\d+)\]/);
		                const value = parseFloat(parts[2]);

		                if (sourceMatch && targetMatch && !isNaN(value)) {
		                  const sourceIndex = parseInt(sourceMatch[1]);
		                  const targetIndex = parseInt(targetMatch[1]);

		                  const linkIndex = importedData.links.findIndex(
                    (link) =>
                      (link.source === sourceIndex ||
                        link.source.index === sourceIndex) &&
                      (link.target === targetIndex ||
                        link.target.index === targetIndex),
		                  );

		                  if (linkIndex !== -1) {
		                    importedData.links[linkIndex].value = Math.max(
                      0.001,
                      value,
                    );
		                  }
		                }
		              });

		            const globalsSection = sections.find((s) =>
              s.includes("Global Variables"),
            );
		            if (globalsSection) {
		              globalsSection
                .split("\n")
		                .filter(
                  (line) =>
                    line.includes(",") && !line.includes("Variable,Value"),
                )
		                .forEach((line) => {
		                  const [variable, value] = line
                    .split(",")
                    .map((v) => v.trim());
		                  if (variable && value) {
		                    const numValue = parseFloat(value);
		                    if (!isNaN(numValue)) {
		                      importedData.globalUpdates[variable] =
                        variable === "HDD" || variable === "GFHDD"
                          ? Math.round(numValue)
                          : parseFloat(numValue.toFixed(3));
		                    }
		                  }
		                });
		            }

		            const buildingSection = sections.find((s) =>
              s.includes("Building Parameters"),
            );
		            if (buildingSection) {
		              buildingSection
                .split("\n")
		                .filter(
                  (line) =>
                    line.includes(",") && !line.includes("Parameter,Value"),
                )
		                .forEach((line) => {
		                  const [parameter, value] = line
                    .split(",")
                    .map((v) => v.trim());
		                  if (parameter === "B.3 Conditioned Area") {
		                    const numValue = parseFloat(value);
		                    if (!isNaN(numValue)) {
		                      importedData.globalUpdates["conditionedArea"] = Math.max(
                        0.001,
                        numValue,
                      );
		                    }
		                  }
		                });
		            }

		            const componentAreasSection = sections.find((s) =>
              s.includes("Component Areas"),
            );
		            if (componentAreasSection) {
		              componentAreasSection
                .split("\n")
		                .filter(
                  (line) =>
                    line.includes(",") && !line.includes("Component,Area"),
                )
		                .forEach((line) => {
		                  const [component, areaStr] = line
                    .split(",")
                    .map((v) => v.trim());
		                  const area = parseFloat(areaStr);
		                  if (!isNaN(area)) {
		                    const componentKey = Object.keys(
                      CONFIG.BUILDING_ELEMENTS.COMPONENTS,
		                    ).find(
                      (key) =>
                        CONFIG.BUILDING_ELEMENTS.COMPONENTS[key].name ===
                        component,
                    );

		                    if (componentKey) {
		                      if (!importedData.componentUpdates.has(component)) {
		                        importedData.componentUpdates.set(component, {});
		                      }
		                      const updates =
                        importedData.componentUpdates.get(component);
		                      updates.area = Math.max(0.001, area);
		                    }
		                  }
		                });
		            }

		            const componentUValuesSection = sections.find((s) =>
              s.includes("Component U-Values"),
            );
		            if (componentUValuesSection) {
		              componentUValuesSection
                .split("\n")
		                .filter(
                  (line) =>
                    line.includes(",") && !line.includes("Component,U-Value"),
                )
		                .forEach((line) => {
		                  const [component, uValueStr] = line
                    .split(",")
                    .map((v) => v.trim());
		                  const uValue = parseFloat(uValueStr);
		                  if (!isNaN(uValue)) {
		                    const componentKey = Object.keys(
                      CONFIG.BUILDING_ELEMENTS.COMPONENTS,
		                    ).find(
                      (key) =>
                        CONFIG.BUILDING_ELEMENTS.COMPONENTS[key].name ===
                        component,
                    );

		                    if (componentKey) {
		                      if (!importedData.componentUpdates.has(component)) {
		                        importedData.componentUpdates.set(component, {});
		                      }
		                      const updates =
                        importedData.componentUpdates.get(component);
		                      updates.uvalue = Math.max(0.001, uValue);
		                    }
		                  }
		                });
		            }

		            resolve(importedData);
		          } catch (error) {
		            console.error("CSV parsing error:", error);
		            reject(error);
		          }
		        };

		        reader.onerror = reject;
		        reader.readAsText(file);
		      });
		    },

		    async handleXLSXImport(file) {
		      return new Promise((resolve, reject) => {
		        const reader = new FileReader();

        reader.onload = async (event) => {
		          try {
		            console.log("=== Starting XLSX Import ===");
		            const data = new Uint8Array(event.target.result);
		            const workbook = XLSX.read(data, {
		              cellStyles: true,
		              cellFormulas: true,
		              cellDates: true,
		              cellNF: true,
		              sheetStubs: true,
		            });

		            const importedData = {
		              nodes: JSON.parse(JSON.stringify(originalData.nodes)),
		              links: JSON.parse(JSON.stringify(originalData.links)),
		              globalUpdates: {},
		              componentUpdates: new Map(),
		            };

		            // First process global values including conditioned area and nGainsFactor
		            console.log("\nProcessing Global Values...");
		            Object.entries(CONFIG.EXCEL_MAPPING.GLOBAL_VALUES).forEach(
              ([key, cellRef]) => {
		                const [sheet, cell] = cellRef.split("!");
		                const value = workbook.Sheets[sheet]?.[cell]?.v;

                if (value !== undefined) {
		                  // Handle heating system type first (string value)
		                  if (key === "M.1 Primary Heating System") {
		                    const systemValue = value?.toString().toLowerCase();
		                    let mappedSystem = "Heatpump"; // default
		                    if (systemValue.includes("gas")) mappedSystem = "Gas";
		                    else if (
                      systemValue.includes("electric") &&
                      !systemValue.includes("pump")
                    )
		                      mappedSystem = "Electricity";
		
                    // Update the heating system dropdown
		                    const heatingSystemSelect =
                      document.getElementById("heatingSystem");
		                    if (heatingSystemSelect) {
		                      heatingSystemSelect.value = mappedSystem;
		                      // Trigger the change event
		                      const event = new Event("change", { bubbles: true });
		                      heatingSystemSelect.dispatchEvent(event);
		                    }
		
                    importedData.globalUpdates[key] = mappedSystem;
		                    importedData.globalUpdates["heatingSystem"] = mappedSystem;
		                    console.log(
                      `Heating System imported and set to: ${mappedSystem}`,
                    );
		                  }
		                  // Handle numeric values
		                  else {
		                    const numValue = parseFloat(value);
		                    if (!isNaN(numValue)) {
		                      // Handle degree days
		                      if (key === "HDD" || key === "GFHDD") {
		                        importedData.globalUpdates[key] = Math.round(numValue);
		                      }
		                      // Handle conditioned area
		                      else if (key === "B.3 Conditioned Area") {
		                        importedData.globalUpdates[key] = numValue;
		                        importedData.globalUpdates["conditionedArea"] =
                          numValue;
		                      }
		                      // Handle gains factor
		                      else if (key === "nGainsFactor") {
		                        const gainsFactor = numValue;
		                        importedData.globalUpdates[key] = gainsFactor;

                        // Set the dropdown selection
		                        const selector =
                          document.getElementById("gainsFactorMethod");
		                        if (selector) {
		                          if (gainsFactor <= 0.0) selector.value = "0.0";
		                          else if (gainsFactor <= 0.4) selector.value = "0.4";
		                          else if (gainsFactor <= 0.5) selector.value = "0.5";
		                          else if (gainsFactor <= 0.6) selector.value = "0.6";
		                          else selector.value = "phpp";

                          // Update the calculated display
		                          const display = document.getElementById(
                            "calculatedGainsFactor",
                          );
		                          if (display) {
		                            display.textContent =
                              gainsFactor > 0.6
                                ? `(${(gainsFactor * 100).toFixed(2)}%)`
                                : `(${selector.value * 100}%)`;
		                          }
		                        }
		                      }
		                      // Handle all other numeric values
		                      else {
		                        importedData.globalUpdates[key] = parseFloat(
                          numValue.toFixed(3),
                        );
		                      }
		                      console.log(
                        `Global Value ${key}: ${importedData.globalUpdates[key]}`,
                      );
		                    }
		                  }
		                }
		              },
            );

		            // Process direct node values (kWh values)
		            console.log("\nProcessing Direct kWh Values...");
		            const telComponents = [
		              "B.4 Roof",
              "B.5 Walls Above Grade",
              "B.6 Floor Exposed",
              "B.7.0 Doors",
		              "B.8.1 Windows N",
              "B.8.2 Windows E",
              "B.8.3 Windows S",
              "B.8.4 Windows W",
              "B.8.5 Skylights",
		              "B.9 Walls Below Grade",
              "B.10 Floor Slab",
              "B.12 TB Penalty",
              "B.18.3 Air Leakage",
		            ];

		            // Map TEL total directly
		            const telValue = parseFloat(
              workbook.Sheets["ENERGY BALANCE"]?.["F22"]?.v,
            );
		            if (!isNaN(telValue)) {
		              const telLink = importedData.links.find(
                (l) =>
		                  l.source === NodeUtils.findNodeIndex("Building") &&
		                  l.target === NodeUtils.findNodeIndex("Total Envelope Losses"),
		              );
		              if (telLink) {
		                telLink.value = Math.max(0.001, telValue);
		                console.log(`Updated Total TEL: ${telValue}`);
		              }
		            }

		            Object.entries(CONFIG.EXCEL_MAPPING.NODE_VALUES).forEach(
              ([nodeName, cellRef]) => {
		                // Skip _area and _uvalue entries
		                if (
                  !nodeName.includes("_area") &&
                  !nodeName.includes("_uvalue")
                ) {
		                  const [sheet, cell] = cellRef.split("!");
		                  const value = workbook.Sheets[sheet]?.[cell]?.v;

                  if (value !== undefined) {
		                    const numValue = parseFloat(value);
		                    if (!isNaN(numValue)) {
		                      // Special handling for M21S/M21D/TED/G5
		                      if (nodeName === "M.2.1.S Sink (Air/Ground)") {
		                        const link = importedData.links.find(
                          (l) =>
                            l.source ===
                              NodeUtils.findNodeIndex(
                                "M.2.1.S Sink (Air/Ground)",
                              ) &&
		                            l.target ===
                              NodeUtils.findNodeIndex("Thermal Energy Demand"),
		                        );
		                        if (link) {
		                          link.value = Math.max(0.001, numValue);
		                          console.log(`Updated M21S: ${numValue}`);
		                        }
                      } else if (nodeName === "M.2.1.D Energy Input") {
		                        const link = importedData.links.find(
                          (l) =>
		                            l.source ===
                              NodeUtils.findNodeIndex("M.2.1.D Energy Input") &&
		                            l.target ===
                              NodeUtils.findNodeIndex("Thermal Energy Demand"),
		                        );
		                        if (link) {
		                          link.value = Math.max(0.001, numValue);
		                          console.log(`Updated M21D: ${numValue}`);
		                        }
                      } else if (nodeName === "Thermal Energy Demand") {
		                        const link = importedData.links.find(
                          (l) =>
                            l.source ===
                              NodeUtils.findNodeIndex(
                                "Thermal Energy Demand",
                              ) &&
                            l.target === NodeUtils.findNodeIndex("Building"),
		                        );
		                        if (link) {
		                          link.value = Math.max(0.001, numValue);
		                          console.log(`Updated TED: ${numValue}`);
		                        }
		                      }
		                      // Handle TEL components
		                      else if (telComponents.includes(nodeName)) {
		                        const link = importedData.links.find(
                          (l) =>
		                            l.source ===
                              NodeUtils.findNodeIndex(
                                "Total Envelope Losses",
                              ) &&
                            l.target === NodeUtils.findNodeIndex(nodeName),
		                        );
		                        if (link) {
		                          link.value = Math.max(0.001, numValue);
		                          console.log(
                            `Updated TEL component ${nodeName}: ${numValue}`,
                          );
		                        }
		                      }
		                      // Handle other gains/losses
		                      else {
		                        const isLoss =
                          nodeName.startsWith("B.") ||
		                          nodeName === "V.2.3 Unrecovered Ventilation" ||
		                          nodeName === "W.2.W SHW Wasted" ||
		                          nodeName === "G.5 Unusable Gains";

		                        if (isLoss) {
		                          const link = importedData.links.find(
                            (l) =>
                              l.source ===
                                NodeUtils.findNodeIndex("Building") &&
		                              l.target === NodeUtils.findNodeIndex(nodeName),
		                          );
		                          if (link) {
		                            link.value = Math.max(0.001, numValue);
		                            console.log(
                              `Updated loss link ${nodeName}: ${numValue}`,
                            );
		                          }
		                        } else {
		                          const link = importedData.links.find(
                            (l) =>
		                              l.source === NodeUtils.findNodeIndex(nodeName) &&
		                              l.target === NodeUtils.findNodeIndex("Building"),
		                          );
		                          if (link) {
		                            link.value = Math.max(0.001, numValue);
		                            console.log(
                              `Updated gain link ${nodeName}: ${numValue}`,
                            );
		                          }
		                        }
		                      }
		                    }
		                  }
		                }
		              },
            );

		            // In handleXLSXImport, modify the component processing:
		            Object.keys(CONFIG.BUILDING_ELEMENTS.COMPONENTS).forEach(
              (componentKey) => {
		                const component =
                  CONFIG.BUILDING_ELEMENTS.COMPONENTS[componentKey];
		                const areaRef =
                  CONFIG.EXCEL_MAPPING.NODE_VALUES[`${component.name}_area`];
		                const rsiRef =
                  CONFIG.EXCEL_MAPPING.NODE_VALUES[`${component.name}_rsi`];
		                const uValueRef =
                  CONFIG.EXCEL_MAPPING.NODE_VALUES[`${component.name}_uvalue`];

		                if (!importedData.componentUpdates.has(component.name)) {
		                  importedData.componentUpdates.set(component.name, {});
		                }

                const updates = importedData.componentUpdates.get(
                  component.name,
                );

                // Process area if available
		                if (areaRef) {
		                  const [areaSheet, areaCell] = areaRef.split("!");
		                  const areaValue = workbook.Sheets[areaSheet]?.[areaCell]?.v;
		                  if (areaValue !== undefined) {
		                    // Store exact imported value, even if zero
		                    updates.area = areaValue === 0 ? 0.001 : areaValue;
		                    console.log(
                      `${component.name} area: ${areaValue} (original) → ${updates.area} (stored)`,
                    );
		                  }
		                }

		                // Process RSI if available
                if (rsiRef) {
		                  const [rsiSheet, rsiCell] = rsiRef.split("!");
		                  const rsiValue = workbook.Sheets[rsiSheet]?.[rsiCell]?.v;
		                  if (rsiValue !== undefined && rsiValue > 0) {
		                    updates.rsi = rsiValue;
		                    updates.uvalue = 1 / rsiValue; // Calculate U-value for display only
		                  }
		                }
		              },
            ); //,--DO I NEED THE REST OF THIS SHIT BEFORE THE END OF THE BLOCK?

		            resolve(importedData);
		          } catch (error) {
		            console.error("XLSX parsing error:", error);
		            reject(error);
		          }
		        };

		        reader.onerror = reject;
		        reader.readAsArrayBuffer(file);
		      });
		    },
		  },
		};
</script>
	<!-- Script Block 8: Application Controller -->
<script defer>
	const Application = {
	  async initialize() {
	    try {
	      console.log("=== Application Init Start ===");

	      data = JSON.parse(JSON.stringify(INITIAL_DATA));
	      originalData = JSON.parse(JSON.stringify(INITIAL_DATA));

	      // Initialize global variables
	      TED = 0;
	      M21D = 0;
	      M21S = 0;

	      COPh = CONFIG.VALUE_LIMITS.COP_HEATING.default;
	      previousCOPh = CONFIG.VALUE_LIMITS.COP_HEATING.default;
	      COPc = CONFIG.VALUE_LIMITS.COP_COOLING.default;
	      MVHR = CONFIG.VALUE_LIMITS.MVHR.default;
	      DWHR = CONFIG.VALUE_LIMITS.DWHR.default;

	      spacingCollapsed = false;
	      widthMultiplier = 1;
	      showEmissions = false;

	      await this.initializeComponents();
	      await this.initializeState();
	      await this.performInitialRender();

	      const balance = EnergyCalculator.calculateEnergyBalance();
	      updateStatus(
	        balance.isBalanced
          ? "Diagram ready - Energy balanced"
          : "Diagram ready - Check energy balance - Note: Cooling Loads Excluded at this time",
	        balance.isBalanced ? "success" : "warning",
	      );
	    } catch (error) {
	      console.error("Application initialization failed:", error);
	      updateStatus("Initialization error: " + error.message, "error");
	    }
	  },

	  async initializeComponents() {
	    try {
	      if (!data?.nodes || !data?.links) {
	        throw new Error("Data structure not properly initialized");
	      }

	      NodeUtils.ensureNodeReferences();
	      StateManager.initialize();
	      SankeyDiagram.initialize();
	      ControlPanel.initialize();

	      return true;
	    } catch (error) {
	      console.error("Component initialization failed:", error);
	      throw new Error(`Component initialization failed: ${error.message}`);
	    }
	  },

	  // REPLACE EXISTING initializeState() method
	  async initializeState() {
	    try {
	      // First validate all links in initial data
	      data.links = LinkUtils.ensureValidLinkStructure();

	      // Store initial values in state
	      const initialValues = {
	        g5: LinkUtils.getLinkValue("Building", "G.5 Unusable Gains"),
	        ted: LinkUtils.getLinkValue("Thermal Energy Demand", "Building"),
	        m21s: LinkUtils.getLinkValue(
          "M.2.1.S Sink (Air/Ground)",
          "Thermal Energy Demand",
        ),
	        m21d: LinkUtils.getLinkValue(
          "M.2.1.D Energy Input",
          "Thermal Energy Demand",
        ),
	      };

	      console.log("Initial values stored:", initialValues);

	      COPh = StateManager.getValue("copHeating");
	      COPc = StateManager.getValue("copCooling");
	      MVHR = StateManager.getValue("mvhrEfficiency");
	      DWHR = StateManager.getValue("dwhrEfficiency");

	      NodeUtils.ensureNodeReferences();

	      // Only update if values different from initial
	      if (Math.abs(TED - initialValues.ted) > 0.1) {
	        EnergyCalculator.updateTEL(true);
	        EnergyCalculator.updateHeatPumpValues(initialValues.ted);
	        EnergyCalculator.updateBuildingBalance();
	      }
	      // Force update of all displays after initialization
	      ControlPanel.updateValueDisplays();
	      ControlPanel.updateTotals();

	      return true;
	    } catch (error) {
	      console.error("State initialization failed:", error);
	      throw new Error(`State initialization failed: ${error.message}`);
	    }
	  },

	  async performInitialRender() {
	    try {
	      const container = document.querySelector(".diagram-container");
	      const width = container.clientWidth;

	      SankeyDiagram.svg.attr("width", width);
	      SankeyDiagram.sankey.extent([
        [1, 1],
        [width - 1, 600 - 1],
      ]);

	      requestAnimationFrame(() => {
	        SankeyDiagram.render(true);
	        ControlPanel.calculateTotalEnergyCost();
	        ControlPanel.calculateTEUI(); // Add initial TEUI calculation
	      });

	      return true;
	    } catch (error) {
	      console.error("Initial render failed:", error);
	      throw new Error(`Initial render failed: ${error.message}`);
	    }
	  },
	};

	// Update status utility function
	function updateStatus(message, type = "pending") {
	  const statusElement = document.getElementById("statusMessage");
	  statusElement.textContent = message;
	  statusElement.className = `status-${type}`;
	}

	// Application startup
	document.addEventListener("DOMContentLoaded", () => {
	  Application.initialize().catch((error) => {
	    console.error("Application startup failed:", error);
	    updateStatus("Application startup failed: " + error.message, "error");
	  });
	});

	// Debug TEUI function
	function debugTEUI() {
	  const teui = ControlPanel.calculateTEUI();
	  console.log("Debug - TEUI calculation:", teui);
	}

	// Debug function to trace value flow
	function debugValueFlow(componentName) {
	  console.log(`=== Value Flow Debug ===`);
	  console.log(`Component: ${componentName}`);

	  // Check link values
	  const telValue = LinkUtils.getLinkValue(
    "Total Envelope Losses",
    componentName,
  );
	  console.log(`TEL → ${componentName}: ${telValue}`);

	  // Check building balance
	  const buildingBalance = EnergyCalculator.calculateEnergyBalance();
	  console.log(`Building balance:`, buildingBalance);

	  // Check node references
	  LinkUtils.verifyNodeReferences();

	  // Check TEUI calculation
	  const teui = ControlPanel.calculateTEUI();
	  console.log(`Final TEUI: ${teui}`);
	}
	//Copyright OpenBuilding.ca 2025. All rights reserved. See Terms and Conditions at https://openbuilding.ca/about/terms-of-use/
	//NOTES - 3032r1 STABLE. Add Print Next.
	window.addEventListener("resize", () => SankeyDiagram.resize());
</script>
</body>
</html>