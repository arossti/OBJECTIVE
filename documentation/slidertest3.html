<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <!-- 
    ============================================================================
    SLIDER TEST 3 - SIMPLIFIED DUAL INPUT SLIDER
    ============================================================================
    
    PURPOSE:
    Demonstrate a simplified implementation of an editable slider component, 
    combining a text input and range slider. This approach aims for simplicity 
    similar to the SANKEY3035 app, while still integrating correctly with the 
    TEUI application's StateManager architecture.
    
    PROBLEM RESOLUTION (vs. slidertest2.html):
    This version directly addresses the over-engineering concerns raised from 
    previous attempts (like slidertest2.html). It avoids complex mechanisms like 
    focus/blur patterns, manual microtask scheduling, and overly aggressive 
    debouncing/materiality checks that were introduced to combat perceived bugs 
    or race conditions. Instead, it relies on standard browser events and trusts 
    the application's central StateManager to handle update propagation and 
    calculation dependencies correctly.
    
    KEY DIFFERENCES FROM slidertest2.html:
    - No manual focus/blur handling for deferring state updates.
    - Text input uses the standard 'change' event (fires on blur/enter).
    - Slider uses standard 'input' (for dragging) and 'change' (for release).
    - Uses a simple throttle on slider 'input' -> StateManager calls to prevent 
      overload, but avoids complex debouncing/materiality logic.
    - Relies entirely on StateManager listeners to trigger calculations, simplifying
      the component itself.
      
    LOGIC:
    1. Text Input & Slider are linked visually: Changes in one update the other's value.
    2. Text Input (on change - blur/enter): 
       - Validates the input.
       - Updates the slider's position.
       - Calls StateManager.setValue() directly with the final value.
    3. Slider (on input - dragging):
       - Updates the text input's displayed value immediately for feedback.
       - Calls a *throttled* StateManager.setValue() to avoid overwhelming the system 
         during rapid movement but still provide reasonably frequent updates.
    4. Slider (on change - release):
       - Calls StateManager.setValue() directly (no throttle) to ensure the final 
         slider position is committed accurately.
    5. StateManager (Simulated): 
       - Receives value updates from the component.
       - Notifies registered listeners (simulating other sections or calculation modules).
    6. Dependent Calculations (Simulated):
       - Listeners attached to the StateManager for the relevant fieldId ('h_15') 
         are triggered when the value changes.
       - These listeners perform the necessary calculations (e.g., T.1, T.2, T.3) and 
         update their respective fields/displays.

    APPROACH:
    - Minimal component-specific logic.
    - Leverages global CSS (4011-styles.css) for consistent styling.
    - Designed to fit cleanly within the existing TEUI table structure (e.g., inside a <td>).
    - Provides immediate visual feedback while ensuring reliable state updates.
    
    ============================================================================
    IMPLEMENTATION GUIDE FOR TEUI CALCULATOR (Section02.js, h_15)
    ============================================================================
    
    1. MODIFY sectionRows in `4011-Section02.js`:
       - Find the definition for row "15".
       - Locate the cell definition for column 'h' (fieldId: "h_15").
       - Change its `type` from "editable" to a new custom type, e.g., "editable_slider".
       - Add necessary configuration parameters (min, max, step, padding, initialValue) 
         directly to the cell definition. Example:
         ```javascript
         "15": {
             // ... other row properties
             cells: {
                 // ... other cells
                 h: { 
                     fieldId: "h_15", 
                     type: "editable_slider", // Use a new type identifier
                     initialValue: "1427.20", // Set initial value
                     min: 10,               // Minimum allowed area
                     max: 100000,           // Maximum allowed area
                     step: 0.1,             // Slider granularity
                     padding: 500,          // Range +/- around current value
                     // No need for separate `value` if using `initialValue` for setup
                     classes: [], // Remove user-input/editable if handled by component
                     section: "buildingInfo",
                     span: 2 
                 },
                 // ... other cells
             }
         },
         ```

    2. UPDATE FieldManager Rendering Logic (in `4011-FieldManager.js`):
       - In the `generateSectionContent` function (around line 350-450), add a 
         case to handle the new `type: "editable_slider"`.
       - When this type is encountered, instead of creating a simple `<td>` content, 
         render the required HTML structure inside the cell:
         ```html
         <div class="inline-slider-group"> 
             <input type="text" 
                    class="value-input user-input editable" 
                    id="${fieldId}-input" 
                    aria-label="${cellDef.label || 'Value'}" 
             >
             <input type="range" 
                    id="${fieldId}-slider" 
                    class="form-range" 
             >
         </div>
         ```
       - Ensure the `fieldId` is used to create unique IDs for the input and slider.

    3. INITIALIZE the Component (in `4011-Section02.js` or `4011-FieldManager.js`):
       - After the FieldManager renders the section containing the slider (e.g., in 
         `onSectionRendered` for Section 2 or after `renderSection` in FieldManager),
         find the newly created input and slider elements by their IDs.
       - Instantiate the `EditableSliderV3` class (copy the class definition from this 
         file into a suitable location, maybe a new `TEUI.Components.js` file or 
         directly into `4011-init.js` or `4011-FieldManager.js`).
       - Pass the configuration (fieldId, inputId, sliderId, min, max, step, padding, 
         initialValue) read from the cell definition in `sectionRows`.
       - IMPORTANT: Make sure the `EditableSliderV3` class uses `window.TEUI.StateManager` 
         instead of the `MockStateManager` used in this test file.
         Example Initialization (likely in `initializeSectionEventHandlers` or `onSectionRendered`):
         ```javascript
         function initializeEditableSliders(sectionId) {
             const sectionElement = document.getElementById(sectionId);
             if (!sectionElement) return;
             
             sectionElement.querySelectorAll('[data-field-id][data-type="editable_slider"]').forEach(containerCell => {
                 const fieldId = containerCell.getAttribute('data-field-id');
                 const config = TEUI.FieldManager.getField(fieldId); // Get config from FieldManager
                 
                 const inputId = `${fieldId}-input`;
                 const sliderId = `${fieldId}-slider`;
                 
                 // Check if elements exist before initializing
                 if (document.getElementById(inputId) && document.getElementById(sliderId)) {
                      // Ensure config provides necessary details like min, max, step, etc.
                      new EditableSliderV3({
                          fieldId: fieldId,
                          textInputId: inputId,
                          sliderId: sliderId,
                          initial: parseFloat(config.initialValue || config.defaultValue || '0'),
                          min: config.min !== undefined ? config.min : 0,
                          max: config.max !== undefined ? config.max : 100000,
                          step: config.step !== undefined ? config.step : 0.1,
                          padding: config.padding !== undefined ? config.padding : 500,
                          stateManager: window.TEUI.StateManager // Pass the real StateManager!
                      });
                 } else {
                      console.warn(`Input/Slider elements not found for ${fieldId}`);
                 }
             });
         }
         // Call this function after the section's HTML is rendered.
         ```

    4. STATE MANAGER & CALCULATIONS:
       - The `EditableSliderV3` component will call `StateManager.setValue('h_15', ...)`.
       - Existing listeners for `h_15` (likely set up in `SectionIntegrator.js` or 
         `Section01.js`) should automatically trigger the necessary dependent 
         calculations (TEUI, Carbon metrics, etc.) when the value changes in the 
         StateManager. 
       - No changes should be needed in the calculation logic itself, as it already 
         relies on `StateManager.getValue('h_15')`.

    5. CSS STYLING:
       - The component uses existing classes (`value-input`, `user-input`, `editable`, 
         `form-range`, `inline-slider-group`). Ensure these are defined correctly 
         in `4011-styles.css` to match the desired appearance (borderless input, etc.).
       - The `inline-slider-group` class provides the flex layout for the text input 
         and slider within the table cell.
    ============================================================================
    -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Slider Test 3 - Simplified Dual Input</title>
    <link href="../4011-styles.css" rel="stylesheet">
    <style>
        /* Minimal test-specific styles */
        body { max-width: 700px; margin: 20px auto; padding: 20px; }
        .component-container { 
            margin-bottom: 24px; 
            border: 1px solid #eee; 
            padding: 20px; 
            /* Simulate being inside a table cell */
            display: flex; 
            align-items: center;
            min-height: 30px; /* Match typical cell height */
        }
        hr { margin: 40px 0; }
        
        /* Use existing styles from 4011-styles.css for the slider group layout */
        .inline-slider-group {
            display: flex;
            align-items: center;
            gap: 8px; /* Spacing between text input and slider */
            width: 100%; /* Take full width of the container cell */
        }
        
        /* Ensure text input uses full available width before slider */
        .inline-slider-group .value-input {
            flex-grow: 1; /* Allow text input to grow */
            min-width: 80px; /* Minimum width */
            text-align: right; /* Align text to the right like other inputs */
            padding-right: 5px; /* Add some padding */
        }
        
        /* Style the range slider */
        .inline-slider-group .form-range {
            flex-grow: 2; /* Allow slider to take more space */
            min-width: 100px;
             accent-color: var(--user-input-color); /* Style slider thumb */
        }

        /* Logging area */
        #log-container {
            margin-top: 30px;
            padding: 10px;
            background-color: #f8f9fa;
            border: 1px solid #ddd;
            border-radius: 4px;
            max-height: 250px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 13px;
        }
        .log-entry { margin: 2px 0; }
        .log-entry.error { color: #dc3545; }
        .log-entry.success { color: #198754; }
        .log-entry.info { color: #0dcaf0; }
        .log-entry.state { color: #6f42c1; }
        .log-entry.calc { color: #fd7e14; }
        .log-entry.ui { color: #0d6efd; }
        #clear-log { margin-top: 5px; font-size: 0.8em; padding: 2px 5px;}

        /* Display area for simulated calculations */
        #calculation-display { margin-top: 15px; padding: 10px; border: 1px solid #ccc; background-color: #f0f0f0;}
        #calculation-display span { display: inline-block; margin-right: 15px; font-weight: bold;}

    </style>
</head>
<body>
    <h1>Slider Test 3 - Simplified Dual Input</h1>
    <p><strong>Approach:</strong> Immediate UI updates. Text input updates StateManager on change (blur/enter). Slider updates StateManager on change (release) and throttled on input (dragging). Relies on StateManager listeners for calculations.</p>

    <div class="component-container" id="h_15_container">
        <!-- This structure mimics how it would be placed in Section 02, col h -->
         <div class="inline-slider-group"> 
             <!-- Text input uses standard classes -->
             <input type="text" 
                    class="value-input user-input editable" 
                    id="h_15-input"
                    aria-label="Conditioned Area"
             >
             <!-- Slider uses standard classes -->
             <input type="range" 
                    id="h_15-slider" 
                    class="form-range" 
             >
         </div>
    </div>

    <hr>

    <!-- Display simulated calculated values -->
    <div id="calculation-display">
        <strong>Simulated Dependent Values:</strong><br>
        <span>T.1 Target (h_6): <span id="h_6-val">--</span></span> | 
        <span>T.1 Actual (k_6): <span id="k_6-val">--</span></span> <br>
        <span>T.2 Target (h_8): <span id="h_8-val">--</span></span> | 
        <span>T.2 Actual (k_8): <span id="k_8-val">--</span></span> <br>
         <span>T.3 Target (h_10): <span id="h_10-val">--</span></span> | 
        <span>T.3 Actual (k_10): <span id="k_10-val">--</span></span>
    </div>

    <!-- Logging -->
    <button id="clear-log">Clear Log</button>
    <div id="log-container">
        <div class="log-entry info">Log messages will appear here...</div>
    </div>

    <script>
    /**
     * SIMPLIFIED SLIDER TEST 3 SCRIPT - CONCISE VERSION
     * Focuses on minimal code for integration into the main application.
     */
    document.addEventListener('DOMContentLoaded', () => {

        // --- Mock StateManager (Replace with window.TEUI.StateManager in real app) ---
        const MockStateManager = {
            state: new Map(),
            listeners: new Map(),
            log(msg, type = 'state') { console.log(`[${type.toUpperCase()}] ${msg}`); }, // Keep console logging for testing
            setValue(fieldId, value, source = 'user-modified') {
                const oldValue = this.state.get(fieldId);
                if (String(oldValue) !== String(value)) {
                    this.state.set(fieldId, value);
                    this.log(`StateManager: setValue('${fieldId}', '${value}')`);
                    this.notifyListeners(fieldId, value, oldValue);
                    return true;
                }
                return false;
            },
            getValue(fieldId) { return this.state.get(fieldId) || null; },
            addListener(fieldId, callback) {
                if (!this.listeners.has(fieldId)) { this.listeners.set(fieldId, new Set()); }
                this.listeners.get(fieldId).add(callback);
                this.log(`StateManager: Listener added for '${fieldId}'`);
            },
            notifyListeners(fieldId, newValue, oldValue) {
                if (this.listeners.has(fieldId)) {
                    this.log(`StateManager: Notifying listeners for '${fieldId}'`);
                    this.listeners.get(fieldId).forEach(cb => cb(newValue, oldValue, fieldId));
                }
            }
        };

        // --- Mock Dependent Calculations ---
        const setupMockCalculations = () => {
            const dependentFields = ['h_6', 'k_6', 'h_8', 'k_8', 'h_10', 'k_10'];
            MockStateManager.addListener('h_15', (newAreaValueStr, ov, sourceFieldId) => {
                if (sourceFieldId !== 'h_15') return;
                MockStateManager.log(`Calculation Triggered by '${sourceFieldId}': value changed to ${newAreaValueStr}`, 'calc');
                const area = parseFloat(String(newAreaValueStr).replace(/,/g, '')) || 1;
                const calcs = {
                    h_6: (1000 / area + 5).toFixed(1),
                    k_6: (1000 / area + 5.1).toFixed(1),
                    h_8: (5000 / area + 2).toFixed(1),
                    k_8: (5100 / area + 2.1).toFixed(1),
                    h_10: (130000 / area).toFixed(1),
                    k_10: (131000 / area).toFixed(1)
                };
                Object.entries(calcs).forEach(([key, val]) => MockStateManager.setValue(key, val, 'calculated'));
                MockStateManager.log(`Calculated: h_6=${calcs.h_6}, h_8=${calcs.h_8}, h_10=${calcs.h_10}`, 'calc');
            });
            dependentFields.forEach(fieldId => {
                MockStateManager.addListener(fieldId, (newValue) => {
                    const displayEl = document.getElementById(`${fieldId}-val`);
                    if (displayEl) { displayEl.textContent = newValue; }
                });
            });
        };

        // --- Minimal Throttle Utility ---
        function throttle(func, limit) {
            let inThrottle;
            return function(...args) {
                const context = this;
                if (!inThrottle) {
                    func.apply(context, args);
                    inThrottle = true;
                    setTimeout(() => inThrottle = false, limit);
                }
            };
        }

        // --- Concise EditableSliderV3 Class ---
        class EditableSliderV3 {
            constructor(options) {
                this.textInput = document.getElementById(options.textInputId);
                this.slider = document.getElementById(options.sliderId);
                this.fieldId = options.fieldId;
                this.stateManager = options.stateManager || MockStateManager;
                this.config = {
                    min: options.min !== undefined ? options.min : 0,
                    max: options.max !== undefined ? options.max : 100,
                    step: options.step !== undefined ? options.step : 0.1,
                    padding: options.padding !== undefined ? options.padding : 500,
                    throttleLimit: options.throttleLimit || 150
                };
                this.currentValue = options.initial || this.config.min;

                this.throttledUpdateState = throttle(this._updateState.bind(this), this.config.throttleLimit);
                this._init();
            }

            _init() {
                this.stateManager.setValue(this.fieldId, this._formatValue(this.currentValue), 'initial');
                this.slider.addEventListener('input', this._handleSliderInput.bind(this));
                this.slider.addEventListener('change', this._handleSliderChange.bind(this));
                this.textInput.addEventListener('change', this._handleTextInputChange.bind(this));
                this.textInput.addEventListener('keydown', e => { if (e.key === 'Enter') { e.preventDefault(); this.textInput.blur(); } });
                this._updateUI(this.currentValue);
            }

            _updateUI(value) {
                const numValue = parseFloat(value);
                if (isNaN(numValue)) return;
                this.currentValue = numValue;

                // Update text input
                this.textInput.value = this._formatNumberForDisplay(numValue);

                // Update slider attributes
                const padding = this.config.padding;
                const min = Math.max(this.config.min, numValue - padding);
                const max = Math.min(this.config.max, numValue + padding);
                this.slider.min = min.toFixed(2);
                this.slider.max = max.toFixed(2);
                this.slider.step = this.config.step;
                // Clamp slider value to its current dynamic min/max
                this.slider.value = Math.max(min, Math.min(max, numValue)).toFixed(2);
            }

            // Format value for display (adds commas)
            _formatNumberForDisplay(num) {
                const fixedNum = Number(num.toFixed(2));
                return isNaN(fixedNum) ? '' : fixedNum.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
            }
            
            // Format value for state (just fixed decimals)
            _formatValue(num) {
                return parseFloat(num).toFixed(2);
            }
            
            // Update state manager helper
             _updateState(value) {
                const formattedValue = this._formatValue(value);
                this.stateManager.setValue(this.fieldId, formattedValue);
             }

            _handleSliderInput(e) {
                const newValue = parseFloat(e.target.value);
                if (!isNaN(newValue)) {
                    this._updateUI(newValue);
                    this.throttledUpdateState();
                }
            }

            _handleSliderChange(e) {
                 const finalValue = parseFloat(e.target.value);
                 if (!isNaN(finalValue)) {
                     this._updateState(finalValue); // Update state directly on release
                 }
            }

            _handleTextInputChange(e) {
                const rawValue = e.target.value.replace(/,/g, '');
                const newValue = parseFloat(rawValue);
                if (!isNaN(newValue)) {
                    const clampedValue = Math.max(this.config.min, Math.min(this.config.max, newValue));
                    this._updateUI(clampedValue);
                    this._updateState(clampedValue); // Update state directly on change
                } else {
                    this._updateUI(this.currentValue); // Revert if invalid
                }
            }
        }

        // --- Initialize ---
        console.log('[INFO] DOM Ready. Initializing...');
        setupMockCalculations();

        const areaSlider = new EditableSliderV3({
            fieldId: 'h_15',
            textInputId: 'h_15-input',
            sliderId: 'h_15-slider',
            initial: 1427.20,
            min: 10,
            max: 100000,
            step: 0.1,
            padding: 500,
            throttleLimit: 150,
            stateManager: MockStateManager
        });

        // Trigger initial calculation display update based on initial state
        MockStateManager.notifyListeners('h_15', MockStateManager.getValue('h_15'), null);

    });
    </script>
</body>
</html> 