<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <!-- 
    ============================================================================
    EDITABLE SLIDER COMPONENT - IMPROVED ARCHITECTURE WITH MATERIALITY THRESHOLDS
    ============================================================================
    
    PURPOSE:
    This file demonstrates a robust implementation of an editable slider component 
    that combines a text input and range slider to edit a single value. This version
    uses focus/blur patterns and microtask scheduling to prevent calculation race
    conditions.
    
    BACKGROUND - CALCULATION RACE CONDITION:
    When originally implemented for the Area field (h_15) in Section 02, a 
    race condition appeared. Adjusting the h_15 slider and then immediately 
    adjusting the Service Life slider (h_13) caused calculations (T.1, T.2, T.3) 
    to display incorrect values.
    
    ROOT CAUSE ANALYSIS:
    Debugging revealed that the issue was caused by:
    1. Too frequent state updates during slider dragging
    2. Lack of materiality thresholds for determining significant changes
    3. No debouncing/throttling of updates during continuous operations
    4. Inconsistent handling between text input and slider controls
    5. Race conditions in the state update and calculation pipeline
    
    SOLUTION: ARCHITECTURAL IMPROVEMENTS
    After reviewing the TEUI architecture, we've adopted a robust approach:
    
    1. SMART TEXT INPUT HANDLING:
       - Text input uses focus/blur pattern to defer updates until editing is complete
       - UI updates immediately while state updates are deferred
       - Microtask scheduling ensures ultra-fast execution with proper timing
    
    2. MATERIALITY THRESHOLDS:
       - Only update state when changes exceed significance thresholds
       - Accumulate minor changes and apply them when input session ends
       - Prevent cascading recalculations for insignificant changes
    
    3. DEBOUNCED SLIDER UPDATES:
       - Implement debouncing for rapid sequential slider movements
       - Allow continuous visual feedback without overwhelming the state system
       - Ensure final values are always committed
    
    4. UNIFIED VALUE PROCESSING:
       - All value changes use a consistent validation and processing pipeline
       - Formal dependency registration with StateManager
    
    CRITICAL FIX (2025.04.19):
    Fixed a regression where manual text entry would break calculations. The issue
    was caused by inconsistent input handling:
    - Slider input was properly using debouncing and materiality thresholds
    - Text input was bypassing these safeguards by forcing immediate state updates
    
    The solution was to apply a simple yet effective text input strategy:
    ```javascript
    // Text input uses focus/blur pattern to defer updates
    handleTextFocus(e) {
        // Mark as editing to defer updates
        this.processingUpdate = true;
        
        // Store the original value for reference
        this.originalValue = this.currentValue;
    }
    
    handleTextChange(e) {
        const numValue = parseFloat(e.target.value.replace(/,/g, ''));
        if (!isNaN(numValue)) {
            // Update UI immediately for feedback
            this.currentValue = numValue;
            this.textInput.value = this.formatNumber(numValue);
            
            // Don't update state yet - wait for blur event
        }
    }
    
    handleTextBlur(e) {
        // Process pending value when focus is lost
        const finalValue = parseFloat(e.target.value.replace(/,/g, ''));
        if (!isNaN(finalValue)) {
            queueMicrotask(() => {
                this.processingUpdate = false;
                
                // Only commit if value changed
                if (finalValue !== this.originalValue) {
                    this.commitValueToState(finalValue);
                }
            });
        }
    }
    ```
    
    This approach ensures:
    1. Text input updates are not processed until editing is complete
    2. UI feedback is still immediate for a responsive experience
    3. Only the final value is committed to the state system
    4. The microtask scheduling prevents flash of incorrect calculations
    
    IMPLEMENTATION DETAILS:
    - Materiality threshold determines if a change is significant enough to update state
    - Debouncing prevents rapid-fire updates during slider dragging
    - Final values are always committed when interaction ends
    - Visual feedback is immediate while state updates are controlled
    
    INTEGRATION GUIDELINES:
    
    1. FIELD DEFINITION (in Section02.js):
       ```javascript
       h: { 
           type: "editable_slider", 
           fieldId: "h_15", 
           value: "1427.20", 
           min: 0,        // Optional fallback
           max: 3000,     // Optional fallback
           step: 0.1,     // Slider increment
           padding: 500,  // +/- range around current value
           label: "Conditioned Area (Net mÂ²)" 
       }
       ```
    
    2. CSS REQUIREMENTS:
       - .inline-slider-group: Flex container for both inputs
       - .value-input: Styles for the text input
       - .form-range: Styles for the range slider
    
    CONFIGURATION OPTIONS:
    - materialityThreshold: Minimum change required to trigger state update (default: 0.1)
    - debounceTime: Milliseconds to wait before triggering final update (default: 250ms)
    - alwaysUpdateOnFinish: Whether to always update state when interaction ends (default: true)
    ============================================================================
    -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Slider Test 2 - Focus/Blur Pattern with Microtask Scheduling</title>
    <link href="4011-styles.css" rel="stylesheet">
    <style>
        /* Minimal test-specific styles only */
        body { max-width: 700px; margin: 20px auto; padding: 20px; }
        .slider-container { margin-bottom: 24px; border: 1px solid #eee; padding: 20px; }
        hr { margin: 40px 0; }
        
        /* Logging area for demonstration */
        #log-container {
            margin-top: 30px;
            padding: 10px;
            background-color: #f8f9fa;
            border: 1px solid #ddd;
            border-radius: 4px;
            max-height: 200px;
            overflow-y: auto;
        }
        #log-container .log-entry {
            margin: 2px 0;
            font-family: monospace;
            font-size: 13px;
        }
        .log-entry.error { color: #dc3545; }
        .log-entry.success { color: #28a745; }
        .log-entry.info { color: #0d6efd; }
        .log-entry.debug { color: #6c757d; }
        .log-entry.warning { color: #ffc107; }
        #clear-log { margin-top: 5px; }
        
        /* Configuration panel */
        .config-panel {
            background-color: #f8f9fa;
            border: 1px solid #ddd;
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 4px;
        }
        .config-panel label {
            display: inline-block;
            width: 180px;
            margin-right: 10px;
        }
        .config-panel input {
            width: 80px;
            margin-right: 10px;
        }
        .config-row {
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <h1>Editable Slider: Focus/Blur Pattern with Microtask Scheduling</h1>
    <p><strong>Key Improvement:</strong> This version uses a focus/blur pattern with microtask scheduling to prevent race conditions. Text input defers state updates until editing is complete, while still providing immediate visual feedback.</p>
    
    <div class="config-panel">
        <h4>Configuration Options</h4>
        <div class="config-row">
            <label for="materiality-threshold">Materiality Threshold:</label>
            <input type="number" id="materiality-threshold" value="0.1" step="0.1" min="0">
            <span>Minimum change required to trigger state update</span>
        </div>
        <div class="config-row">
            <label for="debounce-time">Debounce Time (ms):</label>
            <input type="number" id="debounce-time" value="250" step="50" min="0">
            <span>Ms to wait before triggering final update</span>
        </div>
        <div class="config-row">
            <label for="always-update">Always Update on Finish:</label>
            <input type="checkbox" id="always-update" checked>
            <span>Always update state when interaction ends</span>
        </div>
    </div>

    <div id="standard-slider-container">
        <div class="slider-container">
             <div class="inline-slider-group"> 
                 <input type="text" 
                        class="value-input" 
                        id="standard-area-input"
                        aria-label="Conditioned Area"
                 >
                 <input type="range" 
                        id="standard-area-slider" 
                        class="form-range" 
                 >
             </div>
        </div>
    </div>

    <!-- Logging for demonstration -->
    <button id="trigger-calculation" class="btn btn-primary">Simulate h_13 Change (Triggers Calculation)</button>
    <button id="clear-log" class="btn btn-sm btn-secondary">Clear Log</button>
    <button id="toggle-debug" class="btn btn-sm btn-info">Toggle Debug Logs</button>
    <div id="log-container">
        <div class="log-entry info">Log messages will appear here...</div>
    </div>

    <script>
    /**
     * IMPROVED ARCHITECTURE WITH FOCUS/BLUR PATTERN AND MICROTASK SCHEDULING
     * 
     * This implementation consolidates the key features of the editable slider component:
     * - Focus/blur pattern defers state updates until editing is complete
     * - Microtask scheduling ensures ultra-fast execution with proper timing
     * - Materiality thresholds prevent excessive state updates
     * - Debouncing handles rapid-fire slider movements
     * - Clear separation between UI updates and state changes
     * 
     * ARCHITECTURAL IMPROVEMENTS:
     * - Class-based approach reduces code size while maintaining all functionality
     * - Encapsulation of related methods improves organization and maintainability
     * - Explicit public API simplifies integration with StateManager
     * - Consistent state update patterns prevent calculation race conditions
     * - Configuration through options makes component more reusable
     */
    document.addEventListener('DOMContentLoaded', () => {
        // Create a EditableSlider class to encapsulate functionality
        class EditableSlider {
            constructor(options) {
                // Configuration
                this.config = {
                    id: options.id || 'slider-field',           // Field ID
                    initial: options.initial || 0,              // Initial value
                    padding: options.padding || 100,            // Range padding
                    step: options.step || 0.1,                  // Slider step
                    materialityThreshold: options.materialityThreshold || 0.1,
                    debounceTime: options.debounceTime || 250,
                    alwaysUpdateOnFinish: 
                        options.alwaysUpdateOnFinish !== undefined ? options.alwaysUpdateOnFinish : true
                };
                
                // DOM Elements
                this.textInput = document.getElementById(options.textInputId);
                this.slider = document.getElementById(options.sliderId);
                this.logContainer = options.logContainer ? 
                    document.getElementById(options.logContainer) : null;
                
                // State tracking
                this.currentValue = this.config.initial;
                this.lastCommittedValue = this.config.initial;
                this.pendingUpdates = [];
                this.showDebugLogs = false;
                this.state = {};
                this.dependencies = options.dependencies || [];
                this.processingUpdate = false; // Flag for text input processing
                
                // Initialize
                this.init();
            }
            
            // Initialize the slider
            init() {
                // Create debounced processor
                this.debouncedProcess = this.debounce(
                    this.processValue.bind(this),
                    this.config.debounceTime
                );
                
                // Initialize state
                this.updateState(this.config.id, this.config.initial.toFixed(2), 'initial');
                
                // Register events
                this.registerEvents();
                
                // Update UI with initial values
                this.updateUI();
                
                // Log initialization
                this.log('Component initialized with focus/blur pattern and microtask scheduling', 'success');
            }
            
            // Register event listeners
            registerEvents() {
                // Text input events
                this.textInput.addEventListener('focus', this.handleTextFocus.bind(this));
                this.textInput.addEventListener('blur', this.handleTextBlur.bind(this));
                this.textInput.addEventListener('change', this.handleTextChange.bind(this));
                this.textInput.addEventListener('keydown', e => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        e.target.blur();
                    }
                });
                
                // Slider events
                this.slider.addEventListener('input', this.handleSliderInput.bind(this));
                this.slider.addEventListener('change', this.handleSliderRelease.bind(this));
            }
            
            // Update the UI display
            updateUI() {
                const padding = this.config.padding;
                const min = Math.max(0, this.currentValue - padding);
                const max = this.currentValue + padding;
                
                this.slider.min = min.toFixed(2);
                this.slider.max = max.toFixed(2);
                this.slider.step = this.config.step;
                this.slider.value = this.currentValue.toFixed(2);
                this.textInput.value = this.formatNumber(this.currentValue);
                
                this.log(`UI updated: value=${this.currentValue.toFixed(2)}`, 'debug');
            }
            
            // Format a number for display
            formatNumber(num) {
                return isNaN(num) ? '' : num.toLocaleString(undefined, { 
                    minimumFractionDigits: 2, 
                    maximumFractionDigits: 2 
                });
            }
            
            // Check if a change exceeds the materiality threshold
            exceedsThreshold(oldValue, newValue) {
                const delta = Math.abs(newValue - oldValue);
                return delta >= this.config.materialityThreshold;
            }
            
            // Process value with materiality threshold checking
            processValue(rawValue, force = false) {
                // Skip processing if we're in the middle of a text edit
                if (this.processingUpdate && !force) {
                    this.log(`Skipping process during text edit`, 'debug');
                    return false;
                }
                
                // Clean and validate input
                const stringValue = String(rawValue).replace(/,/g, '').trim();
                const numValue = parseFloat(stringValue);
                
                // Validate the value
                if (!isNaN(numValue) && numValue >= 0 && stringValue !== '') {
                    // Always update UI immediately
                    this.currentValue = numValue;
                    
                    // Only update state if change is significant or forced
                    if (force || this.exceedsThreshold(this.lastCommittedValue, numValue)) {
                        this.commitValueToState(numValue);
                        return true;
                    } else {
                        // Queue minor changes
                        this.pendingUpdates.push(numValue);
                        this.log(`Minor change queued: ${numValue}`, 'debug');
                        return true;
                    }
                }
                
                this.log(`Invalid value: "${rawValue}"`, 'error');
                return false;
            }
            
            // Process pending updates
            processPendingUpdates() {
                if (this.pendingUpdates.length === 0) return;
                
                // Take the last value from the queue
                const finalValue = this.pendingUpdates[this.pendingUpdates.length - 1];
                this.pendingUpdates = [];
                
                // Commit if needed
                if (this.config.alwaysUpdateOnFinish || 
                    this.exceedsThreshold(this.lastCommittedValue, finalValue)) {
                    this.commitValueToState(finalValue);
                }
            }
            
            // Commit a value to state with better timing
            commitValueToState(value) {
                const formattedValue = value.toFixed(2);
                this.log(`Preparing to commit: ${formattedValue}`, 'debug');
                
                // Use microtask for ultra-fast execution
                queueMicrotask(() => {
                    this.updateState(this.config.id, formattedValue, 'user-modified');
                    this.lastCommittedValue = value;
                    this.log(`Value committed to state: ${formattedValue}`, 'success');
                });
            }
            
            // Update the state
            updateState(fieldId, value, source) {
                // Skip state updates during text editing
                if (this.processingUpdate) {
                    this.log(`State update suppressed (processing update): ${fieldId}=${value}`, 'debug');
                    return;
                }
                
                this.state[fieldId] = value;
                this.log(`State updated: ${fieldId}=${value}`, 'success');
                
                // This would trigger dependency updates in real implementation
                // if (window.TEUI && window.TEUI.StateManager) {
                //     window.TEUI.StateManager.setValue(fieldId, value, source);
                // }
            }
            
            // Event Handlers
            handleTextFocus(e) {
                // Mark as editing to defer updates
                this.processingUpdate = true;
                
                // Store the original value for reference
                this.originalValue = this.currentValue;
                this.log(`Text input focus - original value: ${this.originalValue}`, 'info');
            }
            
            handleTextBlur(e) {
                // Process any pending value
                const finalValue = parseFloat(e.target.value.replace(/,/g, ''));
                if (!isNaN(finalValue)) {
                    this.log(`Text input blur - final value: ${finalValue}`, 'info');
                    
                    // Use microtask for ultra-fast execution
                    queueMicrotask(() => {
                        this.processingUpdate = false;
                        
                        // Only commit if value changed
                        if (finalValue !== this.originalValue) {
                            this.log(`Committing changed value to state: ${finalValue}`, 'success');
                            this.commitValueToState(finalValue);
                        } else {
                            this.log(`Value unchanged, not committing`, 'debug');
                        }
                    });
                } else {
                    // Reset to last valid value
                    this.log(`Invalid value on blur, resetting`, 'warning');
                    e.target.value = this.formatNumber(this.currentValue);
                    this.processingUpdate = false;
                }
            }
            
            handleTextChange(e) {
                const numValue = parseFloat(e.target.value.replace(/,/g, ''));
                if (!isNaN(numValue)) {
                    // Update UI immediately for feedback
                    this.currentValue = numValue;
                    this.textInput.value = this.formatNumber(numValue);
                    this.log(`Text input changed: ${numValue} (UI updated, state update deferred)`, 'debug');
                    
                    // Don't update state yet - wait for blur event
                } else {
                    // Handle invalid input
                    this.log(`Invalid text input: "${e.target.value}"`, 'error');
                    e.target.value = this.formatNumber(this.currentValue);
                }
            }
            
            handleSliderInput(e) {
                const numValue = parseFloat(e.target.value);
                if (!isNaN(numValue)) {
                    // Update UI immediately
                    this.currentValue = numValue;
                    this.textInput.value = this.formatNumber(numValue);
                    
                    this.log(`Slider dragging: ${numValue}`, 'debug');
                    
                    // Process with debouncing
                    this.debouncedProcess(numValue);
                }
            }
            
            handleSliderRelease(e) {
                this.processPendingUpdates();
                this.log(`Slider released, processing pending updates`, 'info');
            }
            
            // Utility: Debounce function
            debounce(func, wait) {
                let timeout;
                const debounced = function(value) {
                    const later = () => {
                        clearTimeout(timeout);
                        func.apply(this, [value]);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
                
                // Add cancel method for cleanup
                debounced.cancel = function() {
                    clearTimeout(timeout);
                };
                
                return debounced;
            }
            
            // Utility: Log a message
            log(msg, type = 'info') {
                if (!this.logContainer || (type === 'debug' && !this.showDebugLogs)) return;
                
                const entry = document.createElement('div');
                entry.className = `log-entry ${type}`;
                entry.textContent = msg;
                this.logContainer.appendChild(entry);
                this.logContainer.scrollTop = this.logContainer.scrollHeight;
            }
            
            // Public methods
            getValue() {
                return this.currentValue;
            }
            
            setValue(value, force = false) {
                if (this.processValue(value, force)) {
                    this.updateUI();
                    return true;
                }
                return false;
            }
            
            toggleDebugLogs(enabled) {
                this.showDebugLogs = enabled;
                this.log(`Debug logs ${enabled ? 'enabled' : 'disabled'}`, 'info');
            }
            
            updateConfig(options) {
                Object.assign(this.config, options);
                this.log('Configuration updated', 'info');
            }
            
            // Cleanup method
            destroy() {
                // Cancel any pending debounced calls
                if (this.debouncedProcess && this.debouncedProcess.cancel) {
                    this.debouncedProcess.cancel();
                }
                
                // Remove event listeners
                if (this.textInput) {
                    this.textInput.removeEventListener('focus', this.handleTextFocus);
                    this.textInput.removeEventListener('blur', this.handleTextBlur);
                    this.textInput.removeEventListener('change', this.handleTextChange);
                    this.textInput.removeEventListener('keydown', this.handleKeyDown);
                }
                
                if (this.slider) {
                    this.slider.removeEventListener('input', this.handleSliderInput);
                    this.slider.removeEventListener('change', this.handleSliderRelease);
                }
                
                // Clear references
                this.pendingUpdates = [];
                this.state = {};
                this.textInput = null;
                this.slider = null;
                this.logContainer = null;
            }
        }
        
        // Create instance with initial configuration
        const slider = new EditableSlider({
            id: 'h_15',
            initial: 1427.2,
            padding: 500,
            step: 0.1,
            materialityThreshold: parseFloat(document.getElementById('materiality-threshold').value) || 0.1,
            debounceTime: parseInt(document.getElementById('debounce-time').value) || 250,
            alwaysUpdateOnFinish: document.getElementById('always-update').checked,
            textInputId: 'standard-area-input',
            sliderId: 'standard-area-slider',
            logContainer: 'log-container',
            dependencies: ['t_1', 't_2', 't_3'] // Example dependencies
        });
        
        // Add listeners for configuration controls
        document.getElementById('materiality-threshold').addEventListener('change', updateConfigFromUI);
        document.getElementById('debounce-time').addEventListener('change', updateConfigFromUI);
        document.getElementById('always-update').addEventListener('change', updateConfigFromUI);
        
        function updateConfigFromUI() {
            slider.updateConfig({
                materialityThreshold: parseFloat(document.getElementById('materiality-threshold').value) || 0.1,
                debounceTime: parseInt(document.getElementById('debounce-time').value) || 250,
                alwaysUpdateOnFinish: document.getElementById('always-update').checked
            });
        }
        
        // Toggle debug logs button
        document.getElementById('toggle-debug').addEventListener('click', () => {
            slider.toggleDebugLogs(!slider.showDebugLogs);
        });
        
        // Clear log button
        document.getElementById('clear-log').addEventListener('click', () => {
            const logContainer = document.getElementById('log-container');
            logContainer.innerHTML = '';
            slider.log('Log cleared', 'info');
        });
        
        // Simulate calculation button
        document.getElementById('trigger-calculation').addEventListener('click', () => {
            const value = slider.getValue();
            slider.log('--- CALCULATION TRIGGERED (h_13 change) ---', 'info');
            
            // Process any pending updates before calculation
            slider.processPendingUpdates();
            
            // Simulate calculation
            const area = parseFloat(value);
            if (isNaN(area) || area === 0) {
                slider.log('CALCULATION ERROR: Invalid area value!', 'error');
            } else {
                const teuiValue = (133458 / area).toFixed(1);
                slider.log(`CALCULATION SUCCESS: T.3 TEUI = ${teuiValue}`, 'success');
            }
        });
    });
    </script>
</body>
</html> 